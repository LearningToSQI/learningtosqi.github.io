<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="Fundamental to SQISign is the Deuring correspondence. This gives us a link between the world of elliptic curves and the world of quaternion algebras over $\mathbb{Q}$. In particular, it tells us that the endomorphism ring of a supersingular elliptic curve $E$ defined over $\mathbb{F}_{p^2}$ is isomorphic to a maximal order in $\mathcal{B}_{p, \infty}$, the unique quaternion algebra ramified exactly at $p$ and $\infty$ (up to isomorphism). This correspondence extends to the maps between the elliptic curves: an isogeny $\phi: E \rightarrow E^\prime$ of degree $D$ between supersingular curves corresponds to a left integral $\mathcal{O}$-ideal $I$ of norm $D$, where $\text{End}(E) = \mathcal{O}$."><title>Computing Isogenies from Ideals</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Computing Isogenies from Ideals"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Computing Isogenies from Ideals"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Computing Isogenies from Ideals"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Computing Isogenies from Ideals</h1><p>Fundamental to SQISign is the Deuring correspondence. This gives us a link between the world of elliptic curves and the world of quaternion algebras over $\mathbb{Q}$. In particular, it tells us that the endomorphism ring of a supersingular elliptic curve $E$ defined over $\mathbb{F}_{p^2}$ is isomorphic to a maximal order in $\mathcal{B}_{p, \infty}$, the unique quaternion algebra ramified exactly at $p$ and $\infty$ (up to isomorphism). This correspondence extends to the maps between the elliptic curves: an isogeny $\phi: E \rightarrow E^\prime$ of degree $D$ between supersingular curves corresponds to a left integral $\mathcal{O}$-ideal $I$ of norm $D$, where $\text{End}(E) = \mathcal{O}$. $I$ is also a right $\mathcal{O}^\prime$-ideal, where $\text{End}(E^\prime) = \mathcal{O}^\prime$.</p><p>In this post, we will describe the algorithm <code>IdealToIsogenyFromKLPT()</code>, which computes the isogeny whose kernel corresponds to an input ideal $I$ with left order $\mathcal{O}$. The code which implements this is available at <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/deuring.py><code>deuring.py</code></a>, and is heavily commented.</p><p>Throughout, we will make reference to the special supersingular curve $E_0: y^2 = x^3 + x$ with known endomorphism ring $\text{End}(E_0) = \langle 1, \iota, \frac{\iota + \pi}{2}, \frac{1+\iota\pi}{2}\rangle$, where:</p><p>$$
\iota: (x,y) \mapsto (-x, \sqrt{-1}y), \qquad \pi: (x,y) \mapsto (x^p, y^p).
$$</p><p>$\text{End}(E_0)$ isomorphic to the maximal order $\mathcal{O}_0 = \langle 1, i, \frac{i+j}{2}, \frac{1+ij}{2}\rangle$, where $i^2 = -1$ and $j^2 = -p$, via the isomorphism taking $\iota \mapsto i$ and $\pi \mapsto j$.</p><p>If our input ideal $I$ is a left $\mathcal{O}$-ideal with $\mathcal{O} \neq \mathcal{O}_0$, we actually need more information to compute the corresponding isogeny; we require the knowledge of a <em>connecting ideal</em> $K$ with left order $\mathcal{O}_0$ and right order $\mathcal{O}$, and its corresponding isogeny $\varphi_K: E_0 \rightarrow E$, where $\text{End}(E) \cong \mathcal{O}$. Indeed, to obtain the kernel corresponding to an ideal $I$, we need to know how to map elements of $I$ to endomorphisms of $E$. While we know that, abstractly, the endomorphism ring of $E$ is isomorphic to $\mathcal{O}$, we do not know an <em>explicit</em> (i.e. computable) isomorphism. As we shall see, we can effectively solve this by using a connecting isogeny $E_0 \rightarrow E$ of degree coprime to the norm of $I$.</p><p>On input of two ideal $I$, $K$, with norm $\ell^{\times}$, and corresponding isogeny $\varphi_K$ (as above), the algorithm <code>IdealToIsogenyFromKLPT()</code> proceeds as follows.</p><h3 id=step-1-ideal-filtration>Step 1: Ideal filtration</h3><p>We first compute a chain of ideals</p><p>$$
I = \tilde{I}_v \subset \dots \subset \tilde{I}_1 \subset \tilde{I}_0,
$$</p><p>where each quotient $I_m = \tilde{I}_{m}/\tilde{I}_{m-1}$ has norm $\ell^{\text{step}}$, for some step size, and will correspond to an isogeny $\psi_m$.
We will work with these quotients to break up the corresponding isogeny into smaller sized pieces, so that the kernel can be defined over $\mathbb{F}_{p^2}$. Otherwise, directly computing the isogeny corresponding to $I$ would require a <em>large</em> field extension over which to define the kernel points.</p><figure><img src=/images/smallsteps.png alt="A diagram showing how the isogeny is broken up into small steps using the ideal filtration." width=500px><figcaption><p><strong>Figure 1</strong>: We break up $\varphi_I$ into small steps $\psi_m$ using ideal filtration on $I$.</p></figcaption></figure><p>By construction of the parameters, the largest power of $\ell$ dividing $p^2-1$ is $\ell^f$ (or equivalently, $f$ is the $\ell$-valuation of the order of a supersingular $E$ over $\mathbb{F}_{p^4}$). Therefore, a first choice for $\text{step}$ is $f$.</p><p>Following the SQISign paper, <code>IdealToIsogenySmallFromKLPT()</code> gives tricks to increase $\text{step}$ to $2f_{\text{step}}+\Delta$, where $f_{\text{step}}= f - \epsilon$, for some small positive integer $\epsilon$. We require that $\epsilon > 0$, as we need to be able to access the $2^{f_{\text{step}} + 1}$ torsion when performing endomorphism evaluations. See the page <a href=/posts/ideal-kernel>Between Kernels and Ideals</a> for more context.</p><p>The integer $\Delta$ used to increase the step size corresponds to a brute force computation of an isogeny $\eta$ of degree $\ell^{\Delta}$. As this computation takes $O(\sqrt{\ell^{\Delta}})$ time, $\Delta$ cannot be too large. For details on how this brute force search is implemented see the page
<a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a>.</p><p>If the norm of $I$ is not divisible by $2f_{\text{step}} + \Delta$, then the final quotient $I_\nu$ obtained from the filtration will only have norm $n(I_\nu) \mathrel{|} \ell^{2f_{\text{step}} + \Delta}$. Due to this, for the $m$-th step, we let $\Delta_\text{actual} = \max( n(I_m) - 2f_{\text{step}}, 0)$ (we do not want $\Delta_\text{actual}$ to be negative). If $\Delta_\text{actual} = 0$, we set $f_{\text{step}} = \frac{n(I_k)}{2}$. For clarity of presentation, we will drop the subscript and denote $\Delta_{\text{actual}}$ simply by $\Delta$.</p><h3 id=step-2-find-equivalent-ideal-with-smooth-norm>Step 2: Find equivalent ideal with smooth norm</h3><p>Using <code>EquivalentSmoothIdealHeuristic()</code>, we find an ideal $J$ that is equivalent to $K$ and is of smooth degree dividing $T^2$.</p><p>In some cases, we will already know an ideal of prime norm equivalent to $K$. In these cases, we can remove the call to the subroutine <code>EquivalentPrimeIdealHeuristic()</code>. This is particularly important for the case when $K$ is equivalent to an ideal with small norm (see the page <a href=/posts/small-steps>Small Steps from Curves with Small Endomorphisms</a> for more details).</p><h3 id=step-3-compute-the-isogeny-corresponding-to-j>Step 3: Compute the isogeny corresponding to $J$</h3><p>The norm of $J$ (which divides $T^2$) is coprime to the norm of $K$ (which is $\ell^{\times}$), and so to compute the isogeny $\varphi_J$ corresponding to $J$, we use <code>IdealToIsogenyCoprime()</code>, which we describe in more detail in our blogpost <a href=/posts/ideal-to-isogeny-subroutines/#corresponding-isogeny-of-ideal-with-coprime-norm>Subroutines when Computing Isogenies from Ideals</a>.</p><h3 id=step-4-isogenies-from-filtration>Step 4: Isogenies from filtration</h3><p>We now compute the isogeny corresponding to each quotient.
We skip the first ideal in the filtration $I_0$ as is the unit ideal of $\OO$.</p><p>For each ideal in the filtration, we want to compute the corresponding isogeny $\psi_m$.</p><p>Let $K_1 = K$ and $\varphi_{K_1} = \varphi_K$. For each step $m = 2, \dots, v$, we define</p><p>$$
\begin{aligned}
K_m &= K \cdot I_{1} \cdot \dots \cdot I_{m-1} \\
\varphi_{K_m} &= \psi_{m-1} \circ \dots \circ \psi_1 \circ \varphi_K.
\end{aligned}
$$</p><p>After computing $\psi_m$, we update $K_{m-1}$ and $\varphi_{K_{m-1}}$ to obtain $K_m$ and $\varphi_{K_{m}}$, respectively.</p><p>To compute $\psi_m$ we first multiply ideals $J$ and $I_m$ to obtain $JI_m$. We do this because $JI_m$ has left ideal $\OO_0$ so the corresponding isogeny will be easier to compute, whereas in general, $I_m$ will not.</p><p>We compute the isogeny corresponding to $JI_m$, say $\varphi_{m}$, which satisfies $\varphi_m = \psi_m \circ \varphi_J$. As we know $\varphi_J$, we use this to find $\psi_m$. This procedure is done with <code>IdealToIsogenySmallFromKLPT()</code>. This is the most technical subroutine of the algorithm, as well as being the bottleneck step (primarily as it must be called for <em>all</em> ideals in the filtration). We describe it in more detail here in our blogpost <a href=/posts/ideal-to-isogeny-subroutines>Subroutines when Computing Isogenies from Ideals</a>.</p><p>Before moving to the next step, there is one final detail to explain. To multiply the ideals $J$ and $I_m$ we need the left order of $J$ to match the right order of $I_m$ (not just isomorphic). However, this in general is not the case. We therefore have to supply our <code>multiply_ideals()</code> function with an automorphism that takes $I_m$ to an ideal with correct right order. For more information on this, see <a href=/posts/up-to-iso>Correct up to Isomorphism</a>.</p><h3 id=step-5-patch-together-the-isogeny-factors>Step 5: Patch together the isogeny factors</h3><p>From the previous step, we get a list of isogeny factors that correspond to the ideals in the filtration. We now want to patch them together to obtain our desired isogeny $\varphi_I$. This can be done by composing the isogeny factors as $\psi_v \circ \dots \circ \psi_1$ using SageMath&rsquo;s in-built funciton <code>EllipticCurveHom_composite()</code>.</p><p>Recall that the Deuring correspondence is only true <em>up to isomorphism</em>, so we may have that the codomain of $\psi_m$ is not equal to the domain $\psi_{m+1}$, only isomorphic. Due to this, we may have to post-compose $\psi_{m+1}$ with such an isomorphism.</p><h2 id=edge-cases>Edge cases</h2><h3 id=small-steps-from-e_0>Small steps from $E_0$</h3><p>We run <code>IdealToIsogenyFromKLPT()</code> in both <code>keygen()</code> and <code>reponse()</code> and for each of these cases we have to take some precautions with how the ideal filtration
is performed. The issue is, when we are working with an ideal $I$ which has particularly small norm, <code>EquivalentPrimeIdealHeuristic()</code> is likely to fail and
thus the KLPT algorithm cannot complete. This becomes a problem when we work with some ideal which via the Deuring correspondence is equivalent
to some isogeny $\phi : E_0 \to E$ of small degree.</p><p>Exactly how we deal with these edge cases takes some explaining, so we made a separate page called <a href=/posts/small-steps>Small Steps from Curves with Small Endomorphisms</a>, in which this is discussed in detail. The end claim is
that for <code>IdealToIsogenyFromKLPT()</code>, for <code>keygen()</code> to run successfully we must take the smallest step in the filtration chain first and for <code>response()</code> we must take the smallest step last.</p><p>This is controlled with the optional <code>bool</code> <code>end_close_to_E0</code> available to <code>IdealToIsogenyFromKLPT()</code>. When <code>end_close_to_E0 = True</code>, we have the smallest step first and last otherwise.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>