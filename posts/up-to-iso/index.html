<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="Informally speaking, the Deuring correspondence gives a bijection between maximal orders in the quaternion algebra $\BB$ and the ideals connecting them, to endomorphism rings of supersingular curves over $\mathbb{F}_{p^2}$ and the isogenies between them. However, when computing the isogeny from a given ideal under this correspondence, it will only be correct up to isomorphism. Conversely, the correspondence yields the correct ideal up to equivalence. In the context of isogeny-based cryptography, this does not pose a problem as we are only interested in curves up to isomorphism."><title>Correct up to Isomorphism</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Correct up to Isomorphism"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Correct up to Isomorphism"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Correct up to Isomorphism"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Correct up to Isomorphism</h1><p>Informally speaking, the Deuring correspondence gives a bijection between maximal orders in the quaternion algebra $\BB$ and the ideals connecting them, to endomorphism rings of supersingular curves over $\mathbb{F}_{p^2}$ and the isogenies between them.
However, when computing the isogeny from a given ideal under this correspondence, it will only be correct <em>up to isomorphism</em>. Conversely, the correspondence yields the correct ideal <em>up to equivalence</em>. In the context of isogeny-based cryptography, this does not pose a problem as we are only interested in curves up to isomorphism. However, when working with these objects in practice, it can become an issue.</p><p>To demonstrate this, consider the following situation. Say we have ideals $I$ and $J$ obtained using <code>kernel_to_ideal()</code>, corresponding to isogenies $\varphi_I$ and $\varphi_J$, and we would like to compute $IJ$. For the multiplication to be well-defined, we must have that the orders are compatible in the sense that $O_R(I) = O_L(J)$. In particular, these orders must be the <em>same</em>, not just isomorphic. However, by the Deuring correspondence, <code>kernel_to_ideal()</code> will only return the correct $I$ and $J$ up to equivalence, and as a result we can only be certain that $\OO_R(I) \cong \OO_L(J)$.</p><p>The aim of this blogpost is to highlight generic fixes that we used throughout our code to obtain the correct ideals and isogenies.</p><h3 id=obtaining-the-correct-ideal>Obtaining the correct ideal</h3><p>Suppose that we are given two equivalent ideals $I \sim J$. This means that there exists an $\alpha \in \BB^{\times}$ such that $J = I\alpha$. On input $I, J$, our algorithm <code>left_isomorphism()</code> outputs such an $\alpha$.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>left_isomorphism</span>(I, J):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Given two isomorphic left ideals I, J computes
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    α such that J = I*α
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    B <span style=color:#fe8019>=</span> I<span style=color:#fe8019>.</span>quaternion_algebra()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> B <span style=color:#fe8019>!=</span> J<span style=color:#fe8019>.</span>quaternion_algebra():
</span></span><span style=display:flex><span>        <span style=color:#fe8019>raise</span> <span style=color:#fb4934>ValueError</span>(<span style=color:#b8bb26>&#34;Arguments must be ideals in the same algebra.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> I<span style=color:#fe8019>.</span>left_order() <span style=color:#fe8019>!=</span> J<span style=color:#fe8019>.</span>left_order():
</span></span><span style=display:flex><span>        <span style=color:#fe8019>raise</span> <span style=color:#fb4934>ValueError</span>(<span style=color:#b8bb26>&#34;Arguments must have the same left order.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IJ <span style=color:#fe8019>=</span> I<span style=color:#fe8019>.</span>conjugate() <span style=color:#fe8019>*</span> J
</span></span><span style=display:flex><span>    L <span style=color:#fe8019>=</span> reduced_basis(IJ)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>for</span> t <span style=color:#fe8019>in</span> L:
</span></span><span style=display:flex><span>        α <span style=color:#fe8019>=</span> t <span style=color:#fe8019>/</span> I<span style=color:#fe8019>.</span>norm()
</span></span><span style=display:flex><span>        <span style=color:#fe8019>if</span> J <span style=color:#fe8019>==</span> I <span style=color:#fe8019>*</span> α:
</span></span><span style=display:flex><span>            <span style=color:#fe8019>return</span> α
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>raise</span> <span style=color:#fb4934>ValueError</span>(<span style=color:#b8bb26>&#34;Could not find a left isomorphism...&#34;</span>)
</span></span></code></pre></div><p>The correctness of <code>left_isomorphism()</code> follows from the proof of Lemma 1 in the <a href=https://eprint.iacr.org/2020/1240>original SQISign paper</a>. Indeed,
if $I$ and $J$ have the same left order, we can identify the ideal $\bar{I}J$ to the principal ideal $\OO_R(I)\beta$. Then, $J = \chi_I(\beta) = I\frac{\beta}{n(I)}$.
Our code considers $\beta$ in the LLL reduced basis of $\bar{I}J$, so that $\beta$ has reduced norm $n(I)n(J)$, and $I\frac{\beta}{n(I)}$ has norm $n(J)$.</p><p>Now let us turn our attention to multiplying ideals $I$ and $J$ using our algorithm <code>multiply_ideals()</code>, which will work if the orders of $I$ and $J$ are compatible. If we only have $\OO_R(I) \cong \OO_L(J)$ but we know a $K \sim I$ with $\OO_R(K) = \OO_L(J)$, we are still able to multiply the ideals $I$, $J$ by supplying extra information to <code>multiply_ideals()</code>.</p><p>We first compute $\beta$ such that $I = K \beta$ by running <code>left_isomorphism(K, I)</code>, and then set $J&rsquo; = \beta^{-1}J \beta$. We then compute $IJ$ as $IJ&rsquo;$. The latter is computable as $I\beta^{-1}J \beta = KJ\beta$ and $K$ and $J$ have compatible orders.</p><p>We note that, by definition, $n(J) = n(J&rsquo;)$. This is important as we usually require the norm of $J$ to have certain properties. For example, $J$ will usually be the output of <code>EquivalentSmoothIdealHeuristic()</code>, and we therefore want it to have smooth norm.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>multiply_ideals</span>(I, J, beta<span style=color:#fe8019>=</span><span style=color:#fe8019>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Computes I*J when O_R(I) ≃ O_L(J)
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    If these orders do not match, we compute
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    as isomorphism which takes O_L(J) to O_R(I)
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> I<span style=color:#fe8019>.</span>right_order() <span style=color:#fe8019>!=</span> J<span style=color:#fe8019>.</span>left_order():
</span></span><span style=display:flex><span>        <span style=color:#fe8019>if</span> beta <span style=color:#fe8019>is</span> <span style=color:#fe8019>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#fe8019>raise</span> <span style=color:#fb4934>ValueError</span>(
</span></span><span style=display:flex><span>                <span style=color:#b8bb26>&#34;Right and left orders, do not match. Must supply an automorphism, beta&#34;</span>
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        J <span style=color:#fe8019>=</span> beta <span style=color:#fe8019>**</span> (<span style=color:#fe8019>-</span><span style=color:#d3869b>1</span>) <span style=color:#fe8019>*</span> J <span style=color:#fe8019>*</span> beta
</span></span><span style=display:flex><span>        <span style=color:#fe8019>assert</span> I<span style=color:#fe8019>.</span>right_order() <span style=color:#fe8019>==</span> J<span style=color:#fe8019>.</span>left_order(), <span style=color:#b8bb26>&#34;Orders does still not match&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> I <span style=color:#fe8019>*</span> J
</span></span></code></pre></div><p>To see this in action, look at <code>IdealToIsogenyFromKLPT()</code> available in the file <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/deuring.py><code>deuring.py</code></a>. If $I_m$ is the ideal at step $m$ of the filtration, we want to compute $JI_m$. However, to do this we must supply <code>multiply_ideals()</code> with the automorphism <code>left_isomorphism(K, J)</code>.</p><h3 id=obtaining-the-correct-isogeny>Obtaining the correct isogeny</h3><p>Suppose we have computed an isogeny $\varphi: E_1 \rightarrow E$, however the codomain is only certain to be correct up to isomorphism. Namely, we <em>actually</em> need an isogeny $\varphi&rsquo;: E_1 \rightarrow E&rsquo;$, where $E \cong E&rsquo;$. Using SageMath&rsquo;s in-built functions, this is easy to fix: we first compute the isomorphism $\psi: E \rightarrow E&rsquo;$ using <code>E.isomorphism_to(E')</code> and then set $\varphi&rsquo; = \psi \circ \varphi$.</p><p>If instead we are in a situation where the domain is incorrect, instead of post-composing, we simply <em>pre-compose</em> with the appropriate isomorphism.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>