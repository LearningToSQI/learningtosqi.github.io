<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="SQISign is an isogeny-based signature scheme that exploits the Deuring correspondence, which connects the world of supersingular elliptic curves over $\mathbb{F}_{p^2}$ to the world of quaternion algebras. More precisely, we have a one-to-one map between the following objects:
Supersingular $j$-invariants over $\mathbb{F}_{p^2}$ (up to Galois conjugacy) $\leftrightarrow$ Maximal orders in $\mathcal{B}_{p, \infty}$ such that $\OO \cong \text{End}(E)$ (up to isomorphism). An isogeny $\varphi: E \rightarrow E_1$ of degree $D$ $\leftrightarrow$ an integral left $\OO$-ideal and right $\OO_1$-ideal $I_{\varphi}$ of norm $n(I_\phi) = D."><title>Overview</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Overview"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Overview"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Overview"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Overview</h1><p>SQISign is an isogeny-based signature scheme that exploits the Deuring correspondence, which connects the world of supersingular elliptic curves over $\mathbb{F}_{p^2}$ to the world of quaternion algebras. More precisely, we have a one-to-one map between the following objects:</p><ol><li>Supersingular $j$-invariants over $\mathbb{F}_{p^2}$ (up to Galois conjugacy) $\leftrightarrow$ Maximal orders in $\mathcal{B}_{p, \infty}$ such that $\OO \cong \text{End}(E)$ (up to isomorphism).</li><li>An isogeny $\varphi: E \rightarrow E_1$ of degree $D$ $\leftrightarrow$ an integral left $\OO$-ideal and right $\OO_1$-ideal $I_{\varphi}$ of norm $n(I_\phi) = D.$</li><li>An endomorphism $\theta \in \text{End}(E_0)$ $\leftrightarrow$ A principal ideal $\OO \cdot \theta$.</li></ol><p>If we have two isogenies $\varphi: E \rightarrow E_1$ and $\psi: E \rightarrow E_1$ (i.e., two isogenies with the same domain and codomain), they will correspond to equivalent ideals $I_{\varphi} \sim I_{\psi}$. This correspondence also behaves well with <em>multiplication</em> of ideals. Namely the ideal $I_{\rho} \cdot I_{\tau}$ is equal to $I_{\tau \circ \rho}$ and therefore corresponds to the isogeny $\tau \circ \rho$.</p><p>Developing efficient algorithms for the maps translating objects to and from the geometric world of elliptic curves and algebraic world of quaternions has been the focus of many works, including for example <a href=https://eprint.iacr.org/2014/505>[KLPT14]</a>, <a href=https://eprint.iacr.org/2016/1154>[GPS17]</a>, <a href=https://eprint.iacr.org/2018/371>[EHLMP18]</a>, <a href=https://eprint.iacr.org/2020/1240>[DKLPW20]</a>, <a href=https://eprint.iacr.org/2021/919>[W21]</a>, <a href=https://eprint.iacr.org/2022/234>[DLW22]</a>, and <a href=https://eprint.iacr.org/2023/106>[EPSV23]</a>.</p><ol><li>Given a $j$-invariant $j(E)$, it is computationally <em>hard</em> to compute the corresponding maximal order as this would require the computation of the endomorphism ring of $E$, which is conjectured to be a hard problem. In fact, this underlies the security of isogeny-based cryptography. Indeed, the quaternion $\ell$-isogeny problem, which is the analogue of the $\ell$-isogeny problem in quaternion algebras, can be solved in polynomial time ( and )
conversely, given the maximal order $\OO$, it is easy to compute the corresponding supersingular elliptic curve.</li><li>By following the $\textsf{IdealToIsogeny}$ and $\textsf{IsogenyToIdeal}$ algorithms introduced in the SQISign paper, we are able to implement efficient algorithms for the translation of ideals to and from isogenies.</li></ol><p>SQISign is obtained from a high-soundness, one round interactive identification protocol by the Fiat-Shamir transform. In our code, we implement this identification protocol, as described in the <a href=https://eprint.iacr.org/2020/1240><em>original</em> paper</a>, which consists of the following algorithms:</p><ul><li><code>Setup</code>: on input of the security parameter $\lambda$, pick a suitable prime number $p$ and let $E_0: y^2 = x^3 + x$ be the special supersingular curve over $\mathbb{F}_{p^2}$. Throughout, we will fix $p \equiv 3 \bmod 4$. Then, select an odd, smooth, $\lambda$-bit numbers $D_c, T&rsquo;$ with $\gcd(D_c, T&rsquo;) = 1$ which divide $(p^2 - 1)$. Let $D = 2^e$, where $e$ is greater than the diameter of the $2$-isogeny graph.</li><li><code>Keygen</code>: given parameters, pick a random isogeny $\tau: E_0 \rightarrow E_A$ of prime degree $N_{\tau}$, leading to a random elliptic curve $E_A$. The public key is $E_A$ and the secret key is the isogeny $\tau$.</li><li><code>Commitment</code>: the prover generates a random (secret) isogeny walk $\psi: E_0 \rightarrow E_1$ of degree $T&rsquo;$ and sends $E_1$ to the verifier.</li><li><code>Challenge</code>: the verifier sends the degree-$D_c$ cyclic isogeny $\varphi: E_1 \rightarrow E_2$ to the prover.</li><li><code>Response</code>: from $\varphi \circ \psi \circ \widehat{\tau}: E_A \rightarrow E_2$, the prover constructs a new isogeny $\sigma: E_A \rightarrow E_2$ of degree $D$ with $\widehat{\varphi}\circ \sigma$ cyclic, and sends $\sigma$ to the verifier.</li><li><code>Verify</code>: the verifier accepts the response if $\sigma$ is a degree-$D$ isogeny from $E_A$ to $E_2$ and the isogeny $\widehat{\varphi}\circ \sigma : E_A \to E_1$ is cyclic. If any of these conditions are not met, the verifier rejects the response.</li></ul><figure><img src=/images/sqisign.png alt="A diagram showing the SQISign Identification Protocol." width=500px><figcaption><p><strong>Figure 1</strong>: The SQISign Identification Protocol. Diagram inspired by Figure 1 in the <a href=https://eprint.iacr.org/2020/1240>original SQISign paper</a></p></figcaption></figure><p>We now discuss these in more depth.</p><h3 id=setup>Setup</h3><p>We implement this in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/setup.py><code>setup.py</code></a>, which computes all the global variables needed for the various algorithms given parameter sets designed for SQISign in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/parameters.py><code>parameters.py</code></a>.</p><p>In the parameters file, we currently have two parameters sets from which to chose: a toy $54$-bit prime $p_{\text{toy}}$, for which SQISign takes around 30 seconds to run; and a cryptographic sized $256$-bit prime $p_{6983}$ which terminates in around 12 minutes at the time of writing.</p><p>The remaining algorithms (from key generation to verification) can all be found in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/SQISign.py><code>SQISign.py</code></a>.</p><h3 id=key-generation>Key generation</h3><p><strong>Note</strong>: We implement the efficient alternative key generation as described in Appendix D of the <a href=https://eprint.iacr.org/2020/1240>SQISign paper</a>:</p><ol><li>Select a prime $N_{\tau} \leq B_{\tau} \simeq p^{1/4}$ that is inert in $\mathbb{Z}[i]$ uniformly at random (note that this is specific to $p \equiv 3 \bmod 4$; otherwise we require it to be inert in $\mathbb{Z}[\omega]$, the ring of integers of $\mathcal{B}_{p, \infty}$).</li><li>Compute an endomorphism $\gamma \in \OO_0$ of norm $N_{\tau} \ell^{e_\tau}$, where $e_{\tau} \approx \log(p)$, by running $\textsf{RepresentInteger}_{\OO_0} (N_{\tau} \ell^{e_\tau})$.</li><li>Set $I_{\tau} = \OO_0 \gamma + \OO_0 N_{\tau}$, which will be an integral left $\OO_0$-ideal of prime norm $N_{\tau}$.</li><li>Set $J_{\tau} = \OO_0\bar{\gamma} + \OO_0\ell^{e_\tau}$, which will be a cyclic left $\OO_0$-ideal of smooth norm $\ell^{e_\tau}$ equivalent to $I_\tau$.</li><li>Compute the isogeny $\tau&rsquo;$ corresponding to $J_{\tau}$ using <code>IdealToIsogenyFromKLPT()</code> with <code>end_close_to_E0 = True</code>. The flag signals that $J_{\tau}$ is equivalent to an ideal of (relatively) small norm, which may cause <code>EquivalentPrimeIdealHeuristic()</code> to fail. Indeed, $J_{\tau} \sim I_{\tau}$ with $n(I_\tau) \simeq \sqrt[4]{p}$. To see more details on this, see the page <a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>.</li><li>The secret key will then be the degree $n(J_\tau)$ isogeny $\tau&rsquo;: E_0 \rightarrow E_A$ with corresponding public key $E_A$. We also return the (secret) ideals $I_{\tau}, J_{\tau}$ as these will be useful for future computations.</li></ol><h3 id=commitment>Commitment</h3><p>To generate the commitment isogeny, we first generate a torsion basis $E_0[T&rsquo;] = \langle P_0, Q_0 \rangle$. We then compute a secret integer $x$ and with this construct the kernel generator $K_\psi = P_0 + [x]Q_0$ such that $\psi : E_0 \to E_0 / \langle K_\psi \rangle = E_1$.</p><p>Next, by calling <code>kernel_to_ideal()</code>, we compute the ideal $I_{\psi}$ corresponding to the commitment isogeny $\psi: E_0 \rightarrow E_1$.
We keep as secret data the isogeny $\psi$ and the ideal $I_\psi$, and send as the codomain $E_1$ as our commitment to allow the generation of a challenge.</p><h3 id=challenge>Challenge</h3><p>The verifier receives $E_1$, the codomain of $\psi$, and computes the challenge isogeny kernel $\ker(\varphi)$ by computing a basis $E_1[D_c] = \langle P_1, Q_1\rangle$ and then computing a random kernel $\ker(\phi) = \langle P_1 + [x]Q_1\rangle$.</p><h3 id=response>Response</h3><p>The response is the most technical and slowest algorithm in the SQISign identification protocol. It runs as follows.</p><ol><li>Compute $\bar{I}_{\tau} \cdot I_{\psi} \cdot I_{\varphi}$ which corresponds to the isogeny $\varphi \circ \psi \circ \widehat{\tau}$. As $\ker(\phi) \not\in E_0$, computing $I_\phi$ is inefficient. Instead, the product $I_{\psi} \cdot I_{\varphi}$ can be computed directly from the intersection $I_{\psi} \cap I_{[\psi]^\star \phi} = I_{\psi} \cap I_{[\widehat{\psi}]_*\varphi}$. For more details on how this is done, see the page <a href=/posts/pushforwards/>Pushforwards and Pullbacks</a>. Then we run <code>multiply_ideals()</code> on $\bar{I}_{\tau}$ and $I_{\psi} \cdot I_{\varphi}$ to obtain an ideal $I$.</li><li>Run <code>SigningKLPT()</code> on $I$ to obtain a cyclic ideal $J \sim I$ of norm $\ell^e$, where $e$ is a fixed global parameter. See <a href=/posts/klpt-bounds/#setting-the-signing-length-of-sqisign>Estimating Bounds for KLPT</a> for a discussion on how we set the size of $e$. Here, as $I$ is a left $\OO$-ideal where $\OO \neq \OO_0$, so we need to provide a connecting $(\OO_0, \OO)$-ideal as a second input. In this case, our second input is $J_{\tau}$.</li><li>We now want to find the isogeny corresponding to $J$. As $J$ is not a left $\OO_0$-ideal, we need to provide a left $\OO_0$-ideal whose right order is $\OO_L(J)$. By adjusting by an isomorphism if necessary, $J_{\tau}$ is such an ideal. Refer to the page <a href=/posts/up-to-iso/>Correct up to Isomorphism</a> for more information on computing isomorphisms).</li><li>Given the ideal $J, J_\tau$, we then calculate $\sigma$ as the isogeny corresponding to $J$ using <code>IdealToIsogenyFromKLPT</code> with $J_{\tau}$ and its corresponding isogeny $\tau&rsquo;$ as additional input.</li><li>We compress the isogeny $\sigma$ as a bitstring $S$ using <code>compression</code>, more information about the compression and following decompression is given on the page <a href=/posts/compression/>Modifying Compression</a>.</li></ol><p>The output of this algorithm is the bitstring $S$.</p><h3 id=verify>Verify</h3><p>After decompressing the bitstring $S$ to obtain $\sigma$, the verification algorithm is a composition of the following checks:</p><ul><li>The codomain of $\sigma$ is isomorphic to $E_2$.</li><li>The degree of $\sigma$ is $D = 2^e$.</li><li>The isogeny $\widehat{\varphi} \circ \sigma$ is cyclic.</li></ul><p>This last check is done by computing a torsion basis $E_A[2^f] = \langle P, Q \rangle$. The isogeny $\widehat\phi \circ \sigma$ is cyclic if and only if there are points in the image of this isogeny. It is enough to check $\widehat\phi \circ \sigma(P)$ and $\widehat\phi \circ \sigma(Q)$, and check if either has order $2^f$.</p><p>If all the checks pass, we return <code>True</code>. Otherwise, <code>False</code>.</p><h2 id=contents>Contents</h2><p>We now give a short overview of the posts accessible on this website. The purpose of these posts is to highlight difficulties we encountered when implementing the algorithms above and explaining potential areas of confusion.</p><h3 id=background>Background</h3><ul><li><a href=/posts/cyclic-ideals>Working with Cyclic Ideals</a>: in SQISign, we are interested in integral, cyclic ideals. We give an overview of these objects and how one can ensure a given ideal is cyclic.</li><li><a href=/posts/up-to-iso/>Correct up to Isomorphism</a>: in many places, the Deuring correspondence is only correct up to isomorphism, but we must correct for exactness for the protocol to be successful. We discuss computing isomorphisms of ideals and isogenies.</li><li><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a>: we describe how to compute the pushforwards and pullbacks of isogenies and ideals, which are vital for mapping to and from the curve $E_0$ with known endomorphism ring.</li></ul><h3 id=klpt-for-sqisign>KLPT for SQISign</h3><ul><li><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a>: we discuss how we can set heuristic bounds for the KLPT algorithm such that we have a high chance of success for each call of <code>EquivalentSmoothIdealHeuristic()</code>.</li><li><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>: one aspect of the KLPT algorithm requires computing equivalent prime norm ideals. This can fail on certain edge cases and this post aims to communicate how each edge-case is dealt with.</li><li><a href=/posts/strong-approximation-lattice>Strong Approximation Lattice Trick</a>: we can ensure the output of the KLPT has a small norm by using a lattice trick when solving the strong approximation. This page gives a detailed overview of how this works and how we have implemented it.</li></ul><h3 id=computing-isogenies-from-ideals>Computing isogenies from ideals</h3><ul><li><a href=/posts/ideal-kernel>Between Kernels and Ideals</a>: at the core of the conversion of ideals and isogenies is the mapping between isogeny kernel generators and quaternion algebra generators of ideals. This page discusses how to implement the evaluation of endomorphisms $\alpha \in \BB$ on points $P \in E$ and then follows with a description of $\textsf{KernelToIsogeny}$ and $\textsf{IsogenyToKernel}$.</li><li><a href=/posts/ideal-to-isogeny>Computing Isogenies from Ideals</a>: we detail the algorithm that, given a cyclic ideal, computes the corresponding isogeny using <code>IdealToIsogenyFromKLPT()</code>; the algorithm introduced in the SQISign paper which allows for the construction of a high-soundness identification protocol.</li><li><a href=/posts/ideal-to-isogeny-subroutines>Subroutines when Computing Isogenies from Ideals</a>: the above algorithm is complicated, and so to help readers, we factor out subroutines used in <code>IdealToIsogenyFromKLPT()</code> into a separate page.</li><li><a href=/posts/meet-in-the-middle>Meet in the Middle Isogenies</a>: one step in the above algorithm is the brute force search of an $\ell^\Delta$ degree isogeny. We implement this with a meet in the middle algorithm using a depth-first search of the graph of j-invariants.</li></ul><h3 id=sqisign-subtleties>SQISign subtleties</h3><ul><li><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a>: When we attempt to run the KLPT algorithm on an ideal which connects two left orders with particularly small norm, there is a chance the sub-algorithm to compute equivalent prime norm ideals may fail. This page gives detail on when we expect this to happen and how we pick an ideal filtration to ensure the protocol is successful.</li><li><a href=/posts/compression/>Modifying Compression</a>: for our implementation, we found that we needed to include an additional bit to the compression algorithm to ensure successful decompression. This page details this bit, as well as giving a detailed discussion on the implementation of compression and decompression.</li></ul><h3 id=conclusions>Conclusions</h3><ul><li><a href=/posts/future-work/>Future Work</a>: we summarise plans for future work, which are mainly focused between implementing the most modern description of SQISign following <a href=https://eprint.iacr.org/2022/234>New algorithms for the Deuring correspondence: toward practical and secure SQISign signatures</a> and the hope to improve the performance of isogeny computations in the current code.</li></ul><h2 id=correspondence-between-notation>Correspondence between notation</h2><p>Due to the number of papers that have developed algorithms relating to the Deuring correspondence, there are various names out there for the same algorithm. Below we give a non-exhaustive list of equivalent names for algorithms in our code that appear in: the original SQISign paper; and <a href=https://www.lix.polytechnique.fr/Labo/Antonin.LEROUX/manuscrit_these.pdf>Leroux&rsquo;s thesis</a>. We compare to these as they have associated implemented code.</p><table><thead><tr><th><strong>Our Code</strong></th><th><strong>SQISign</strong></th><th><strong>Leroux&rsquo;s Thesis</strong></th></tr></thead><tbody><tr><td><code>EquivalentSmoothIdealHeuristic</code></td><td>$\textsf{KLPT}_{l^*}$</td><td>$\textsf{KLPT}_{\mathcal{N}}$</td></tr><tr><td><code>IdealToIsogenyFromKLPT</code></td><td>$\textsf{IdealToIsogeny}_{l^*}$</td><td>$\textsf{IdealToIsogenyFromKLPT}_{l^*}$</td></tr><tr><td><code>IdealToIsogenySmallFromKLPT</code></td><td>$\textsf{IdealToIsogeny}_{l^{2f+\Delta}}$</td><td>$\textsf{IdealToIsogenySmallFromKLPT}$</td></tr><tr><td><code>IdealToIsogenyCoprime</code></td><td>$\textsf{SpecialIdealToIsogeny}$</td><td>$\textsf{IdealToIsogenyCoprime}_T$</td></tr></tbody></table><p>Note that throughout our code, we add <em>heuristic</em> to the end of algorithm names to indicate when an algorithm with some (small) probability of failure, and therefore may have to be run $N$ times before terminating.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>