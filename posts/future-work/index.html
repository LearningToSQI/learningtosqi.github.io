<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="New SQISign Currently, our implementation follows the original 2020 paper: SQISign: compact post-quantum signatures from quaternions and isogenies, by Luca De Feo, David Kohel, Antonin Leroux, Christophe Petit, and Benjamin Wesolowski.
However, in 2022, an eprint was put online called New algorithms for the Deuring correspondence, which has new descriptions of ideal to kernel algorithms which estimate an approximate two-fold speed up for both keygen and signing.
At the time of writing this blog, the paper has just been updated ready for EUROCRYPT 2023: New algorithms for the Deuring correspondence: toward practical and secure SQISign signatures, by Luca De Feo, Antonin Leroux, Patrick Longa and Benjamin Wesolowski."><title>Future Work</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Future Work"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Future Work"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Future Work"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Future Work</h1><h2 id=new-sqisign>New SQISign</h2><p>Currently, our implementation follows the original 2020 paper: <a href=https://eprint.iacr.org/2020/1240>SQISign: compact post-quantum signatures from quaternions and isogenies</a>, by Luca De Feo, David Kohel, Antonin Leroux, Christophe Petit, and Benjamin Wesolowski.</p><p>However, in 2022, an eprint was put online called <em>New algorithms for the Deuring correspondence</em>, which has new descriptions of ideal to kernel algorithms
which estimate an approximate two-fold speed up for both keygen and signing.</p><p>At the time of writing this blog, the paper has just been updated ready for EUROCRYPT 2023: <a href=https://eprint.iacr.org/2022/234>New algorithms for the Deuring correspondence: toward practical and secure SQISign signatures</a>, by Luca De Feo, Antonin Leroux, Patrick Longa and Benjamin Wesolowski.</p><p>This is a really beautiful paper with some exciting results. Aside from anything else, the new implementation is 3-4x faster
across all of the SQISign protocol!</p><p>With the publication of these new results, this SageMath implementation can really only be considered as a prelude
to implementing modern SQISign, but everyone has to start somewhere.</p><p>The main focus of future work will be implementing all of the additional improvements from this new paper so that we can
bring the SageMath implementation of SQISign up to the current standard. However, before we do this, there are a few
low hanging fruit left in our current implementation that should be addressed. We discuss a few of these below.</p><h2 id=faster-isogenies>Faster Isogenies</h2><p>The current bottleneck of our implementation of SQISign is the computation of the large $\ell$-isogenies
when computing the various isogenies needed within <code>IdealToIsogenySmallFromKLPT()</code>. In fact, when running
SQISign, approximately 75% of the total computation time is spent within <code>EllipticCurveIsogenyFactored()</code>,
which is a wrapper function around SageMath&rsquo;s own <code>EllipticCurveIsogeny</code> which has a few performance improvements,
such as using the <code>velusqrt</code> algorithm when $\ell > 400$.</p><p>When we started working on SQISign, we took a shortcut in following the specification. Rather than write our own
$x$-only isogeny computations, we extended the base field to $\mathbb{F}_{p^4}$ so that the available torsion
for our curves $E / \mathbb{F}_{p^4}$ is $(p^2 - 1)$. This meant sacrificing performance
(one would expect arithmetic for $\mathbb{F}_{p^4}$ to be about four times slower than over $\mathbb{F}_{p^2}$),
but gaining the ability to use all of SageMath&rsquo;s built-in functions for isogenies and to focus our attention on all the other
algorithms we would need for SQISign.</p><p>Now, with a working implementation of SQISign, our focus can shift to refactoring the code and working with
$x$-only operations, so we can compute isogenies on $E / \mathbb{F}_{p^2}$. This should end up with an approximate
four times speed up. However, once all the additional code surrounding the multiplication is taken into account,
we find that the speed-up is not nearly so dramatic.</p><p>As a first example, let us take some large prime $\ell$ which divides $(p+1)$. We can compute an isogeny of this degree
over either $\mathbb{F}_{p^2}$ or $\mathbb{F}_{p^4}$, and this should guide us to how much time we could save:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>sage: p <span style=color:#fe8019>=</span> <span style=color:#d3869b>73743043621499797449074820543863456997944695372324032511999999999999999999999</span>
</span></span><span style=display:flex><span>sage: l <span style=color:#fe8019>=</span> <span style=color:#d3869b>6983</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>assert</span> l<span style=color:#fe8019>.</span>divides(p<span style=color:#fe8019>+</span><span style=color:#d3869b>1</span>)
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Computation over Fp4, as is currently performed</span>
</span></span><span style=display:flex><span>sage: Fp4<span style=color:#fe8019>.&lt;</span>z4<span style=color:#fe8019>&gt;</span> <span style=color:#fe8019>=</span> GF(p<span style=color:#fe8019>^</span><span style=color:#d3869b>4</span>)
</span></span><span style=display:flex><span>sage: E4 <span style=color:#fe8019>=</span> EllipticCurve(Fp4, [<span style=color:#d3869b>1</span>,<span style=color:#d3869b>0</span>])
</span></span><span style=display:flex><span>sage: P4 <span style=color:#fe8019>=</span> ((p<span style=color:#fe8019>^</span><span style=color:#d3869b>2</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span>) <span style=color:#fe8019>//</span> l) <span style=color:#fe8019>*</span> E4<span style=color:#fe8019>.</span>random_point()
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>assert</span> P4<span style=color:#fe8019>.</span>order() <span style=color:#fe8019>==</span> l
</span></span><span style=display:flex><span>sage: 
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Compute isogeny using Vélu&#39;s formula</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E4<span style=color:#fe8019>.</span>isogeny(P4)
</span></span><span style=display:flex><span><span style=color:#d3869b>2</span> s ± <span style=color:#d3869b>31.1</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>1</span> loop each)
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># vélusqrt offers a significant speed up</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E4<span style=color:#fe8019>.</span>isogeny(P4, algorithm<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;velusqrt&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#d3869b>276</span> ms ± <span style=color:#d3869b>8.85</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>1</span> loop each)
</span></span><span style=display:flex><span>sage:
</span></span><span style=display:flex><span>sage:
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Now, perform the &#34;same&#34; computation over Fp2 instead</span>
</span></span><span style=display:flex><span>sage: Fp2<span style=color:#fe8019>.&lt;</span>z2<span style=color:#fe8019>&gt;</span> <span style=color:#fe8019>=</span> GF(p<span style=color:#fe8019>^</span><span style=color:#d3869b>2</span>)
</span></span><span style=display:flex><span>sage: E2 <span style=color:#fe8019>=</span> EllipticCurve(Fp2, [<span style=color:#d3869b>1</span>,<span style=color:#d3869b>0</span>])
</span></span><span style=display:flex><span>sage: P2 <span style=color:#fe8019>=</span> ((p<span style=color:#fe8019>+</span><span style=color:#d3869b>1</span>) <span style=color:#fe8019>//</span> l) <span style=color:#fe8019>*</span> E2<span style=color:#fe8019>.</span>random_point()
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>assert</span> P2<span style=color:#fe8019>.</span>order() <span style=color:#fe8019>==</span> l
</span></span><span style=display:flex><span>sage:
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Compute isogeny using Vélu&#39;s formula</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E2<span style=color:#fe8019>.</span>isogeny(P2)
</span></span><span style=display:flex><span><span style=color:#d3869b>1.65</span> s ± <span style=color:#d3869b>38.6</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>1</span> loop each)
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># vélusqrt offers a significant speed up</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E2<span style=color:#fe8019>.</span>isogeny(P2, algorithm<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;velusqrt&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#d3869b>174</span> ms ± <span style=color:#d3869b>3.37</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>10</span> loops each)
</span></span></code></pre></div><p>From this tiny experiment, it seems that the saving from multiplications in $\mathbb{F}_{p^2}$ are not dominant as one may expect due to the other aspects of the SageMath functions.
Performing over $\mathbb{F}_{p^2}$ for Vélu&rsquo;s formulas seems to save about 20%, while for the $\sqrt{\text{élu}}$
algorithm, the saving is closer to 40%.
We see that there is still time
to be saved, so it is important for us to work on, but how this work should be done is not so obvious.</p><p>One option would be to ditch the in-built SageMath isogeny computations and work on our own $x$-only isogeny implementation.
This would require more development and would move away from &ldquo;SQISign in SageMath&rdquo; to something closer to
&ldquo;SQISign in Python&rdquo;, but it may result in a multiplicative speed up like we are hoping for. We can also specialise
to Montgomery and Edwards curves, for which there are particularly efficient implementations of computing the
action and codomain of isogenies. These are not suitable for general purpose isogenies in SageMath (not every
elliptic curve can even be written in Montgomery form), but it would be suitable for us and align more closely with the C implementation.</p><h2 id=friends-of-friends-of-quaternions>Friends of Friends of Quaternions</h2><p>While working on implementing SQISign, a complementary piece of research
<a href=https://ia.cr/2023/106>Deuring for the People: Supersingular Elliptic Curves with Prescribed Endomorphism Ring in General Characteristic</a>
by Jonathan Komada Eriksen, Lorenz Panny, Jana Sotáková, and Mattia Veroni, was published.</p><p>In the paper, there are several nice implementation tricks to improve the general performance of sub-algorithms while
working with the Deuring correspondence, most of which carry over directly for SQISign. One in particular is noticing
a simplification to the <code>ideal_to_kernel()</code> algorithm: by evaluating the endomorphism action of the <em>conjugate</em> of the ideal
generator, the ideal&rsquo;s kernel is directly computed, avoiding expensive discrete logarithm computations. This is discussed in more
detail on the page <a href=/posts/ideal-kernel/>Between Kernels and Ideals</a>.</p><p>Following their description, we have implemented this in our own code. There is still more to gain from implementing
various other improvements shown in the paper.</p><p>Their paper was accompanied with SageMath code for the <a href=https://github.com/friends-of-quaternions/deuring>Constructive Deuring Correspondence</a>.
As well as some clean and easy to read code for the KLPT algorithm and ideal to isogeny computations for generic extension fields,
this code included $x$-only isogeny computations. Adapting this code for our own uses seems like a perfect starting point
to improve the performance of the code, but there is an interesting problem to overcome.</p><p>In their code, an $x$-only isogeny is computed by first deriving the kernel polynomial using $x$-only computations.
The isogeny itself is computed using Kohel&rsquo;s algorithm from the kernel polynomial using in-built SageMath functions.
However, when the degree of the isogeny grows (and hence the degree of the kernel polynomial), Kohel&rsquo;s algorithm becomes slow:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>sage: p <span style=color:#fe8019>=</span> <span style=color:#d3869b>73743043621499797449074820543863456997944695372324032511999999999999999999999</span>
</span></span><span style=display:flex><span>sage: l <span style=color:#fe8019>=</span> <span style=color:#d3869b>6983</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>assert</span> l<span style=color:#fe8019>.</span>divides(p<span style=color:#fe8019>+</span><span style=color:#d3869b>1</span>)
</span></span><span style=display:flex><span>sage: Fp2<span style=color:#fe8019>.&lt;</span>z2<span style=color:#fe8019>&gt;</span> <span style=color:#fe8019>=</span> GF(p<span style=color:#fe8019>^</span><span style=color:#d3869b>2</span>)
</span></span><span style=display:flex><span>sage: E <span style=color:#fe8019>=</span> EllipticCurve(Fp2, [<span style=color:#d3869b>1</span>,<span style=color:#d3869b>0</span>])
</span></span><span style=display:flex><span>sage: P <span style=color:#fe8019>=</span> (p<span style=color:#fe8019>+</span><span style=color:#d3869b>1</span>) <span style=color:#fe8019>//</span> l <span style=color:#fe8019>*</span> E<span style=color:#fe8019>.</span>random_point()
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Compute the isogeny using Velu&#39;s algorithm</span>
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E<span style=color:#fe8019>.</span>isogeny(P)
</span></span><span style=display:flex><span><span style=color:#d3869b>1.74</span> s ± <span style=color:#d3869b>35.3</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>1</span> loop each)
</span></span><span style=display:flex><span>sage: <span style=color:#928374;font-style:italic># Compute the isogeny use Kohel&#39;s algorithm </span>
</span></span><span style=display:flex><span>sage: h <span style=color:#fe8019>=</span> E<span style=color:#fe8019>.</span>isogeny(P)<span style=color:#fe8019>.</span>kernel_polynomial()
</span></span><span style=display:flex><span>sage: <span style=color:#fe8019>%</span>timeit E<span style=color:#fe8019>.</span>isogeny(h, check<span style=color:#fe8019>=</span><span style=color:#fe8019>False</span>)
</span></span><span style=display:flex><span><span style=color:#d3869b>5.54</span> s ± <span style=color:#d3869b>500</span> ms per loop (mean ± std<span style=color:#fe8019>.</span> dev<span style=color:#fe8019>.</span> of <span style=color:#d3869b>7</span> runs, <span style=color:#d3869b>1</span> loop each)
</span></span></code></pre></div><p>We see that even though the $x$-only computations would allow us to remain over $\mathbb{F}_{p^2}$, when we have to
work with large $\ell$-degree polynomials for Kohel&rsquo;s, SageMath gets really slow. It is an interesting problem, and
something which might be able to be addressed within SageMath.</p><p>Ultimately, it means that simply adapting the $x$-only code from <em>Deuring for the People</em> will slow down, rather
than speed up our own implementation for SageMath.</p><h2 id=community-feedback>Community Feedback</h2><p>Most of all, we hope that by sharing this code, we encourage others to work on SQISign and other protocols that use the Deuring
correspondence. We have done our best to write code which is easy to read and adapt, but all code can be improved, either by
generalising, making functions more robust or including additional documentation and examples.</p><p>If you are interested in helping with this implementation, either through improvements of existing code or the addition of new code,
please get in contact.
The author&rsquo;s contact details can be found on their personal pages: <a href=https://www.mariascrs.com>Maria</a>, <a href=https://giacomopope.com>Giacomo</a>.</p><p>We also warmly welcome issues being filed on the <a href=https://github.com/LearningToSQI/SQISign-SageMath>GitHub repo</a>,
or pull requests to include new features.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>