<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="Overview The KLPT algorithm, which we call EquivalentSmoothIdealHeuristic(), takes as input a left $\OO_0$-ideal $I$ and a smooth integer $\TT$, and computes an equivalent ideal $J$ with norm $\TT$. There are four main steps:
Compute an ideal $L \sim I$ of norm $N$ using EquivalentPrimeIdealHeuristic(). Next, we run RepresentIntegerHeuristic() to obtain $\gamma \in \OO_0$ of norm $N\TT$. Solving the IdealModConstraint() on input $L, \gamma$ derives $(C_0 : D_0) \in \mathbb{P}^1(\mathbb{Z}/N\mathbb{Z})$ such that $\mu_0 = j(C_0 + \omega D_0)$ where $\gamma\mu_0 \in L$."><title>Strong Approximation Lattice Trick</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Strong Approximation Lattice Trick"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Strong Approximation Lattice Trick"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Strong Approximation Lattice Trick"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Strong Approximation Lattice Trick</h1><h2 id=overview>Overview</h2><p>The KLPT algorithm, which we call <code>EquivalentSmoothIdealHeuristic()</code>, takes as input a left $\OO_0$-ideal $I$ and a smooth integer $\TT$, and computes an equivalent ideal $J$ with norm $\TT$. There are four main steps:</p><ol><li>Compute an ideal $L \sim I$ of norm $N$ using <code>EquivalentPrimeIdealHeuristic()</code>.</li><li>Next, we run <code>RepresentIntegerHeuristic()</code> to obtain $\gamma \in \OO_0$ of norm $N\TT$.</li><li>Solving the <code>IdealModConstraint()</code> on input $L, \gamma$ derives $(C_0 : D_0) \in \mathbb{P}^1(\mathbb{Z}/N\mathbb{Z})$ such that $\mu_0 = j(C_0 + \omega D_0)$ where $\gamma\mu_0 \in L$.</li><li>Run <code>StrongApproximationHeuristic()</code> on input $N$, $C_0, D_0$ to obtain $\mu = \lambda\mu_0 + N\mu_1 \in \OO_0$ of norm dividing $N\TT/n(\gamma)$.</li><li>Set $\beta = \gamma\mu$, then output $J = \chi_L(\beta)$.</li></ol><p>In practice, we run through the factors of $\TT$ (that are large enough for the algorithms to run successfully), so that $J$ has norm <em>dividing</em> $\TT$.</p><p>In this post, we focus on the fourth step: the <em>strong approximation step</em>.</p><h2 id=strong-approximation-algorithm-random-solutions>Strong approximation algorithm: random solutions</h2><p>In the following, we identify the distinguished quadratic subring $R[\omega]$ of $\BB$.
Define a function $f_{\omega}(x,y)$ to return the norm of the element $z = x + \omega y \in R[\omega]$.
In SQISign, we have $p \equiv 3 \bmod 4$, so $\omega = i$ and $f_\omega(x,y) = x^2 + y^2$.
For the rest of this page we assume that $\omega = i$.</p><p>The generic idea of <code>StrongApproximationHeuristic()</code> is
to sample $y, z$ in some randomized way and try to see if we can find a solution $t, x$ to the norm equation $f(t, x) = M âˆ’ pf(y, z)$
using Cornacchia&rsquo;s algorithm.</p><p>Let $\mathcal{D}(\TT)$ be the set of divisors of $\TT$. The $\textsf{StrongApproximation}_{\mathcal{D}(\TT)}$ algorithm works as follows.</p><p>Setting $\mu_0 = j(C_0 + iD_0)$ as in <code>IdealModConstraint()</code>, we want to find $\mu_1$ such that $\mu = \lambda\mu_0 + N\mu_1$ has norm in $\mathcal{D}(\TT)$. Our $\mu_1$ will be of the form: $$\mu_1 = x + iy + j(z + it),$$ and so we want to find a solution $(\lambda,x,y,z,t)$ to the norm equation
$$n(\mu) = N^2f(x,y) + pf(\lambda C_0 + Nz, \lambda D_0 + Nt) = M,$$ where $M \in \mathcal{D}(\TT)$.
Working modulo $N$, we get $$M = pf(\lambda C_0, \lambda D_0) = p\lambda^2 f(C_0, D_0) \bmod N.$$</p><p>So, we first compute $\lambda$ such that</p><p>$$
\lambda^2 = \frac{M}{pf(C_0, D_0)}\bmod N.
$$</p><p>However, such a $\lambda$ exists if and only if the RHS is a quadratic residue modulo $N$. Therefore, in the first step, we run through $M \in \mathcal{D}(\TT)$ with $M \geq N^4p$ (see <a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a>) until $M / (pf(C_0, D_0))$ is a quadratic residue, and then compute the corresponding $\lambda$.</p><p>Next, we generate a random pair $(z, t)$ such that:
$$
M - pf(\lambda C_0 + Nz, \lambda D_0 + Nt) = 0 \bmod {N^2}.
$$ We do this by picking $z$ randomly and then solving a linear equation modulo $N$ to recover $t$.</p><p>Given $\lambda$, we now compute $$M^\prime = \frac{M - pf(\lambda C_0 + Nz, \lambda D_0 + Nt)}{N^2},$$ and determine if the equation $f(x,y) = M^\prime$ has any solutions. If no solution exists we sample another random pair $(z,t)$.</p><p>Once we have found a solution $(x,y)$ for sampled $(z,t)$, we output $$\mu = \lambda j(C_0 + D_0i ) + N(x + i t + j(z + i t)).$$</p><p>The solution $\mu$ will have norm $\Nrd(\mu) = M \geq pN^4$. However, we can obtain smaller solutions creating a special lattice, applying lattice reduction
and using carefully chosen integers rather than random ones.</p><h2 id=efficiently-generating-short-vectors>Efficiently generating short vectors</h2><p>The aim of this section is to explain how we can reduce the size of the output. We do this by obtaining <em>good</em> solutions $(z,t)$ rather sampling a random pair. We define good solutions as the ones corresponding to a small value of $pf(\lambda C_0 + Nz, \lambda D_0 + Nt)$. The key to obtaining such solutions is to observe that the space of solutions modulo $N^2$ is a translated lattice.</p><p>To find good solutions, we do the following:</p><ol><li>Construct the appropriate lattice containing these solutions.</li><li>Construct a <em>target vector</em> of the form $$\begin{bmatrix}
z^\prime \\ t^\prime
\end{bmatrix} + N\begin{bmatrix}
z_0 \\ t_0
\end{bmatrix}$$ and find vectors in the lattice close to this vector. Enumerate these close vectors.</li><li>For each close vector $(z_c,t_c)$, construct $z = \frac{z_c}{N} + z_0$ and $t = \frac{t_c}{N} + t_0$ and if the congruence $$M - pf(\lambda C_0 + Nz, \lambda D_0 + Nt) = 0 \bmod N^2, $$ holds, compute the integer $$M^\prime = \frac{M - pf(\lambda C_0 + Nz, \lambda D_0 + Nt)}{N^2}.$$ If $M^\prime > 0$ continue to the next step, otherwise, try the next close vector.</li><li>Using the Cornacchia algorithm, determine whether there exists a solution $(x,y)$ the norm equation $f(x,y) = M^\prime$. If no such solution exists, return to Step 3 and try another close vector. Otherwise, output $\mu = \lambda\mu_0 + N\mu_1$, where $\mu_0 = j(C_0 + iD_0)$ and $\mu_1 = t + \omega x + j(y + iz)$.</li></ol><p>This is implemented in <code>strong_approximation_construct_lattice()</code> and <code>strong_approximation_lattice_heuristic()</code>
in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/KLPT.py><code>KLPT.py</code></a>.</p><p>We now describe steps 1, 2, and 3 in more detail.</p><h3 id=step-1-constructing-the-lattice>Step 1: constructing the lattice</h3><p>We first describe how to construct the appropriate lattice. We want
$$
\begin{aligned}
&M - pf(\lambda C_0 + Nz, \lambda D_0 + Nt) = 0 \bmod N^2\\
\implies &M - p\lambda^2f(C_0, D_0) - 2p\lambda N \left( C_0 z + D_0 t \right) = 0\bmod N^2 \\
\implies &c_0 - N \left( c_z z + c_t t \right) = 0\bmod N^2.
\end{aligned}
$$ where $c_z = 2p\lambda C_0$, $c_t = 2p\lambda D_0$ and $c_0 = M - p\lambda^2f(C_0,D_0)$.
We translate and scale the lattice by $$(z,t) \mapsto \big(z, t - c_0c_t^{-1}\big).$$ Then, dividing through by $N$, we obtain the relation
$$
\begin{aligned}
c_z z + c_t t = 0\bmod N,
\end{aligned}
$$ for which we get a basis of solutions $(1, - c_zc_t^{-1} \bmod N), (0, N)$.
We consider the lattice defined by matrix
$$
N\begin{bmatrix}
1 & -c_y\cdot c_z^{-1} \bmod N\\ 0 & N
\end{bmatrix}.
$$ Here, the factor of $N$ multiplying the lattice matrix comes from the fact that we divided through by $N$. If $(z,t)$ is contained in this lattice, then $(\frac{z}{N}, \frac{t}{N} + c_0c_t^{-1})$ is a good candidate for a solution to $$M - pf(\lambda C_0 + Ny, \lambda D_0 + Nz) = 0 \bmod N^2.$$</p><p>By considering the discriminant of this lattice and using the Gaussian heuristic, we can show the smallest size of solution we can expect with $M^\prime > 0$ positive is $pN^3$, rather than the $pN^4$ expected by taking random solutions.
Therefore, using this lattice we can then hope to find smaller solutions and correspondingly pick a smaller $M \in \mathcal{D}(\TT)$ of size approximately $pN^3$.</p><p>Though it may be unclear by reading this page in isolation, as $\mu$ has smaller reduced norm, this will decrease the norm of the output ideal and hence the degree of any isogenies computed from ideals generated via KLPT. Ultimately leading to a speed up for <code>keygen()</code> and <code>response()</code> and <code>verify_response()</code> of the SQISign identification protocol (respectively, <code>signing()</code> and <code>verify()</code> in the signature scheme).</p><h3 id=step-2-constructing-the-target-vector>Step 2: constructing the target vector</h3><p>To obtain the target vector, we first try to find a solution to
$$
M - p\lambda^2f(C_0, D_0) - 2\lambda C_0pNz - 2\lambda D_0p Nt = 0\bmod N^2.
$$ The $(z,t)$, however, must lie in $\mathbb{Z}$, and so we set our target vector to be an (integer) approximation of this solution, namely:
$$
\mathbf{v}_t = \begin{bmatrix}
y \\ z
\end{bmatrix} = - \lambda \cdot \begin{bmatrix}
C_0 \\ D_0
\end{bmatrix} - N\cdot \begin{bmatrix}
0 \\ c_0\cdot c_z^{-1} \bmod N
\end{bmatrix},
$$ where $c_z$ as above and $c_0 = M - p\lambda^2f(C_0,D_0)$.
This may not lie on the lattice, but we can hope to find a solution close enough so that the norm is kept close to $pN^3$. By enumerating vectors close to this target vector, we can find good solutions.</p><h3 id=step-3-finding-vectors-close-to-the-target>Step 3: finding vectors close to the target</h3><p>We use <code>generate_close_vectors()</code> implemented in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/lattices.py><code>lattices.py</code></a> to find vectors close to the target (i.e., within a certain bounded distance from the target). It works as follows.</p><ol><li>Use <code>solve_closest_vector_problem()</code> to compute the vector $\mathbf{v}_{\text{closest}}$ in the lattice closest to the target vector $\mathbf{v}_t$. Set $d$ to be the distance between $\mathbf{v}_t$ and $\mathbf{v}$.</li><li>Let $b_0 = \lfloor \frac{M}{p} \rfloor$ and set the norm bound to be $B = \lfloor b_0 + d \rfloor + 2\sqrt{b_0 + d}$.</li><li>Find short vectors of size less than $B$ in the lattice using <code>generate_short_vectors()</code>.</li><li>Using the short vectors $\mathbf{v}_{\text{short}}$ computed in the step above, output close vectors by computing the sum $\mathbf{v}_{\text{closest}} + \mathbf{v}_{\text{short}}$.</li></ol><h3 id=enumerating-short-vectors-using-sagemath>Enumerating short vectors using SageMath</h3><p>The method described above can really only be efficient if it is easy to enumerate many short vectors of a lattice.</p><p>SageMath has a few ways to do this, one of which being associated to the <code>QuadraticForm</code> class with <code>short_vector_list_up_to_length(n)</code>,
but it seemed to be slow and error prone. A first iteration of our implementation called to the Pari function <code>qfminim()</code> which is fairly efficient,
but loads all short vectors into memory so you have to choose how many to look through and compute them all before testing if you have a
good solution.</p><p>We instead used the <code>fpylll</code> library which comes with SageMath, and which allows the enumeration of short vectors. This means
we can built an iterator and test each short solution as we find it. We include the code snippet below, as we hope this could
be useful in many other contexts.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#fe8019>from</span> fpylll <span style=color:#fe8019>import</span> IntegerMatrix, Enumeration, EvaluatorStrategy
</span></span><span style=display:flex><span><span style=color:#fe8019>from</span> fpylll.fplll.gso <span style=color:#fe8019>import</span> MatGSO
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>generate_short_vectors</span>(lattice_basis, bound, count<span style=color:#fe8019>=</span><span style=color:#d3869b>2000</span>):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Given a lattice `lattice_basis`, an upper bound for target 
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    norms and the total count of short vectors wanted, creates 
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    a generator of short vectors of the lattice with 
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    norm &lt; bound.
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># LLL reduce the lattice_basis</span>
</span></span><span style=display:flex><span>    L <span style=color:#fe8019>=</span> lattice_basis<span style=color:#fe8019>.</span>LLL()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Move from Sage world to Fypll world</span>
</span></span><span style=display:flex><span>    A <span style=color:#fe8019>=</span> IntegerMatrix<span style=color:#fe8019>.</span>from_matrix(L)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Gram-Schmidt Othogonalization</span>
</span></span><span style=display:flex><span>    G <span style=color:#fe8019>=</span> MatGSO(A)
</span></span><span style=display:flex><span>    _ <span style=color:#fe8019>=</span> G<span style=color:#fe8019>.</span>update_gso()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Enumeration class on G with `count` solutions</span>
</span></span><span style=display:flex><span>    E <span style=color:#fe8019>=</span> Enumeration(
</span></span><span style=display:flex><span>        G, nr_solutions<span style=color:#fe8019>=</span>count, strategy<span style=color:#fe8019>=</span>EvaluatorStrategy<span style=color:#fe8019>.</span>BEST_N_SOLUTIONS
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># We need the row count when we call enumerate</span>
</span></span><span style=display:flex><span>    r <span style=color:#fe8019>=</span> L<span style=color:#fe8019>.</span>nrows()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># If enumerate finds no solutions it raises an error, so we</span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># wrap it in a try block</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#928374;font-style:italic># The arguments of enumerate are:</span>
</span></span><span style=display:flex><span>        <span style=color:#928374;font-style:italic># E.enumerate(first_row, last_row, max_dist, max_dist_expo)</span>
</span></span><span style=display:flex><span>        short_vectors <span style=color:#fe8019>=</span> E<span style=color:#fe8019>.</span>enumerate(<span style=color:#d3869b>0</span>, r, bound, <span style=color:#d3869b>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>except</span>:
</span></span><span style=display:flex><span>        short_vectors <span style=color:#fe8019>=</span> []
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#fe8019>for</span> _, xis <span style=color:#fe8019>in</span> short_vectors:
</span></span><span style=display:flex><span>        <span style=color:#928374;font-style:italic># Returns values x1,x2,...xr such that</span>
</span></span><span style=display:flex><span>        <span style=color:#928374;font-style:italic># x0*row[0] + ... + xr*row[r] = short vector</span>
</span></span><span style=display:flex><span>        v3 <span style=color:#fe8019>=</span> vector([ZZ(xi) <span style=color:#fe8019>for</span> xi <span style=color:#fe8019>in</span> xis])
</span></span><span style=display:flex><span>        v <span style=color:#fe8019>=</span> v3 <span style=color:#fe8019>*</span> L
</span></span><span style=display:flex><span>        <span style=color:#fe8019>yield</span> v
</span></span></code></pre></div><h2 id=edge-cases>Edge cases</h2><h3 id=powers-of-two>Powers of two</h3><p>As described in <a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>, occasionally it is required that we input an ideal $L$ with norm $N = 2^k$, rather than some large prime.
When this is the case, we will not be able to invert $c_z$ as $2 \mid \gcd(c_z, N)$. Therefore, we must modify <code>StrongApproximationHeuristic()</code> to handle this.</p><p>When constructing the lattice, we double the modulus $N$, and half $c_y$ and $c_z$. More precisely, set the modulus to be $2N$ and $c_y$ and $c_z$ to be $p\lambda C_0$ and $p\lambda D_0$, respectively. We then run Step 3 in the same way.</p><p>Note that care also has to be taken in the previous step with <code>IdealModConstraint()</code>, to see
a little more information, see the comments in <code>check_ideal_mod_constraint()</code>, which is called to make sure $(C_0 : D_0)$ are suitable values.</p><h3 id=composite-modulus>Composite modulus</h3><p>Another edge case happens in <code>SigningKLPT()</code>, where the input modulus $N$ is the product of two large primes. The Strong Approximation step is actually
no different for this case, but instead extra care is taken before computing the short lattice solutions by making sure $\gamma$ is picked in such a way
that $\lambda^2$ is indeed a quadratic residue. Note for efficiency, we will compute $\lambda$ as a square root for each of the factors of $N$ and then
recombine them using the Chinese remainder theorem.</p><p>For more information on running the KLPT for <code>SigningKLPT()</code>, the original <a href=https://eprint.iacr.org/2020/1240>SQISign Paper</a> discusses this edge case very carefully.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>