<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="This page is used to explain the optional argument end_close_to_E0 available to IdealToIsogenyFromKLPT() and why it is necessary to include such that the algorithm can run successfully in SQISign for both keygen() and response(). For a more detailed description of the algorithm IdealToIsogenyFromKLPT(), read the page Computing Isogenies from Ideals.
Motivation We first compute the ideal filtration
$$ I = \tilde{I}_v \subset \dots \subset \tilde{I}_1 \subset \tilde{I}_0, $$
where each quotient $I_m = \tilde{I}_{m}/\tilde{I}_{m-1}$ has norm $\ell^{\text{step}}$."><title>Small Steps from Curves with Small Endomorphisms</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Small Steps from Curves with Small Endomorphisms"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Small Steps from Curves with Small Endomorphisms"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Small Steps from Curves with Small Endomorphisms"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Small Steps from Curves with Small Endomorphisms</h1><p>This page is used to explain the optional argument <code>end_close_to_E0</code> available to <code>IdealToIsogenyFromKLPT()</code> and why it is necessary to include such that the algorithm can run successfully in SQISign for both <code>keygen()</code> and <code>response()</code>. For a more detailed description of the algorithm <code>IdealToIsogenyFromKLPT()</code>, read the page <a href=/posts/ideal-to-isogeny>Computing Isogenies from Ideals</a>.</p><h2 id=motivation>Motivation</h2><p>We first compute the ideal filtration</p><p>$$
I = \tilde{I}_v \subset \dots \subset \tilde{I}_1 \subset \tilde{I}_0,
$$</p><p>where each quotient $I_m = \tilde{I}_{m}/\tilde{I}_{m-1}$ has norm $\ell^{\text{step}}$.</p><p>We have that the left
$\OO_0$-ideal $JI_{m}$ computed in Step 4 of <code>IdealToIsogenyFromKLPT()</code> is equivalent to
$K_{m-1}I_m = K I_1 \cdots I_m$ of norm $n(K)\ell^{m\cdot \text{step}}$.
When computing the ideal filtration, if $\ell^{\text{step}}$ does not divide $n(I)$, then one step will be smaller:
$\ell^{\text{small}} = n(I) \bmod \ell^{\text{step}}$. The value of <code>end_close_to_E0</code> determines whether
this small step should be taken first or last.</p><p>The problem of closeness all boils down to the fact that when we find the isogeny corresponding to $JI_m$,
we use <code>IdealToIsogenySmallFromKLPT()</code>, within which we
run <code>EquivalentPrimeIdealHeuristic()</code> via <code>EquivalentSmoothIdealHeuristic()</code> with $JI_m$ as input.
An important thing to note about this subroutine is that it only cares about the <em>equivalence</em> class of the
input ideal. This means that even if $JI_m$ has large norm, if there is an equivalent ideal with small norm,
the algorithm could still fail.</p><p>When running the equivalent prime norm ideal sub-algorithm of the KLPT algorithm, part of the heuristic success
is that the input ideal is random. However, the curve $E_0$ and corresponding order $\OO_0$ are special in that
the endomorphisms of $E_0$ are particularly small. For some of the inputs we need, the ideals are connected
to this special order have particularly small-norm and our heuristic assumptions are incorrect.</p><p>To illustrate the problem generally, imagine an ideal $I$ with left and right orders $\OO_0$ and $\OO$.
Then consider the isogeny $\phi : E_0 \to E$, such that $\OO \cong \End(E)$. When the curves $E_0$ and $E$
are connected by a small degree isogeny (i.e., they are close in the isogeny graph) then there will be an ideal $J \sim I$
with particularly small norm $n(J) = \deg(\phi)$.
When this is the case, it is very unlikely for some $L \sim I \sim J$ with small prime norm to be found.
For more information on why this is a problem, see <a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>.</p><p><strong>Example</strong>: During <code>keygen()</code> we compute $\tau&rsquo; : E_0 \to E_A$ of $\ell$-power norm approximately of degree
$\deg(\tau&rsquo;) \simeq p$. The ideal equivalent via the Deuring correspondence is $J_\tau$ with
$n(J_\tau) = \deg(\tau&rsquo;)$. However, we know that there is also an equivalent ideal $I_\tau \sim J_\tau$ of norm
$n(I_\tau) \simeq p^{1/4}$, and so $E_0$ and $E_A$ are actually much closer than the norm of $J_\tau$ suggests.
Running <code>EquivalentPrimeIdealHeuristic()</code> with $J_\tau$ as input will compute the reduced basis corresponding
to the much smaller $I_\tau$ and likely find no prime norm ideal $L$.</p><p>For SQISign to run successfully, we need to be able to work around the steps of the algorithm for which the input ideals
have particularly small norm by using clever tricks. The function <code>IdealToIsogenyFromKLPT()</code> is used in both key generation
and in the response. To handle both of these use cases, we need slightly different tricks, and we control this with the
optional <code>bool</code>, <code>end_close_to_E0</code> which determines the order of the step sizes for the filtration. We give more detail
about this for the rest of the section.</p><h2 id=working-around-key-generation>Working around key generation</h2><p>During <code>keygen()</code>, we compute an isogeny $\tau&rsquo; : E_0 \to E_A$ of $\ell$-power norm. Here we have that <em>both</em> ends of the
isogeny are close to $E_0$. The domain of $\tau&rsquo;$ <em>is</em> $E_0$, which is as close as you could ever be and, as explained
above, $E_A$ is connected to $E_0$ by some unknown prime-degree isogeny $\ell \simeq p^{1/4}$. For the intermediate steps
of this algorithm, we will be walking away from $E_0$ and towards $E_A$ with steps of size $n(K) \ell^{m \cdot \text{step}}$.
Essentially, almost every step of this algorithm requires working with ideals which connect curves close to
$E_0$. Our hope is to make the distance just big enough to make everything work.</p><p>The trick for <code>keygen()</code> is to counter-intuitively take the smallest possible step from $E_0$ as the first step.
The idea is to avoid calling <code>EquivalentPrimeIdealHeuristic()</code> all together and instead work with input ideals
of $\ell$ power norm. We can do this so long as the input ideal has norm smaller than $\sqrt{p}$.
For more information, see the page <a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>.</p><p>Let us discuss precisely how this is achieved in practice, which boils down to considering the size of the
current step and the norm of the connecting ideal $n(K)$, both of which are powers of $\ell$.
On input $JI_m$, we can always make an ideal $M$ with norm a power of $\ell$ with the following
steps:</p><ol><li>Find $\alpha$ such that $K = J\alpha$. Then, $\alpha$ will have reduced norm $\frac{n(K)}{n(J)}$.</li><li>Set $M = JI_m \alpha$.</li></ol><p>By construction, $M$ is equivalent to $JI_m$ and will have norm $n(M) = \frac{n(JI_m)n(K)}{n(J)} = n(I_m)n(K) = \ell^\times$.
Providing that $\ell^\times$ is small enough (about $\sqrt{p}$), we can use $M$ as input for KLPT without needing to
compute an equivalent prime norm ideal. If the norm of $M$ is too large, then the lattice solutions from the Strong Approximation
would become too large. Luckily the crossing-over point of $M$ being too large is exactly when we can rely comfortably on
<code>EquivalentPrimeIdealHeuristic()</code> to work as expected for random ideals.</p><p>Concretely, in key generation, we input to our algorithm the ideal $J_{\tau}$ to compute $\tau&rsquo;$.
As $J_{\tau}$ is already a left $\OO_0$-order, the first ideal in the filtration will already be a left $\OO_0$-ideal
and the connecting ideal $K$ is set as unit ideal in $\OO_0$ (so $n(K) = 1$) with corresponding trivial isogeny
$\varphi_K : E_0 \to E_0$.</p><p>The fact that $n(K) = 1$ for the first step is what allows us to use the shortest step first. On the first call, we have
$n(M) = \ell^{\text{small}}$ which will be very small (for SQISign $\ell^{\text{step}} \simeq p^{1/4}$) and so we use this as
our prime power norm ideal $L$ in the KLPT algorithm.</p><p>For the second step, we will have $K$ such that $n(K) = \ell^{\text{small}}$ and the step of $JI_1$ will be a full step of size
$\ell^{\text{step}}$.
Applying the same trick above, we will have that $n(M) = \ell^{\text{step} + \text{small}}$. Again, this will be small enough
we can use this in place of deriving an equivalent prime norm ideal.</p><p>For the third step we are $\ell^{2\cdot \text{step} + \text{small}}$ from $E_0$ and $\ell^\text{step}$ from $E_A$. Remember that as $E_A$
is itself close to $E_0$, if we had saved the smallest step for now, we be $\ell^{3\cdot \text{step}}$ from $E_0$ but only
$\ell^{\text{small}}$ from $E_A$. The closeness to $E_A$ (and hence $E_0$) would mean we are likely to fail. As the norm of
$K$ grows with each step, we cannot use the trick described above to compute a good $M$ this far into the chain.
Having used the small step early and having this step as large as possible is what saves us during <code>keygen()</code>.</p><p>For the final step, we input an ideal equivalent to $J_\tau$ itself and it is hopeless to try and use the above trick. Now, $n(K)$
is too big and the curve $E_A$ is too close to $E_0$ to use <code>EquivalentPrimeIdealHeuristic()</code>.
Luckily, we already know an equivalent prime norm ideal: $I_\tau$. We pass this ideal
as an optional parameter and use it in the last step of the function and do not call <code>EquivalentPrimeIdealHeuristic()</code> at all.</p><p>We see that ultimately three of the four steps for <code>keygen()</code> fall apart without proper handling of edge cases. Luckily,
there are ways to work around each of them.</p><h2 id=responding-with-another-trick>Responding with another trick</h2><p>For the response isogeny $\sigma : E_A \to E_2$, we only have $E_A$ as being close to $E_0$. However, unlike <code>keygen()</code>, we will not have
$n(K) = 1$ as input for the first step, so we cannot hope to use the above trick to do the first steps using $\ell$-power tricks.
Here, the additional input given in this case is $K = J_{\tau} \sim I_{\tau}$, an ideal of norm $\approx p^{1/4}$. At each step of the filtration,
our ideals will be equivalent to a left $\OO_0$-ideal of norm $N_{\tau}\ell^{m\cdot \text{step}}$</p><p>The goal is to make sure that the initial step is large enough for <code>EquivalentPrimeIdealHeuristic()</code> run successfully,
so we set <code>end_close_to_E0</code> to be <code>False</code> and have the first step be as big as possible. This puts the potentially very
small last step at the end, which is no problem, as $E_2$ is far enough from $E_0$ that we do not expect for the corresponding
ideal to have small norm.</p><p>There is however a slightly different problem. Before running the ideal chain for <code>response()</code>, we call <code>IdealToIsogenyCoprime()</code> with $J_\tau$
as input and pass this through to the KLPT algorithm. We know that this is a problematic ideal and so we cannot run this as intended, but
luckily again we have $I_\tau$. By passing this in as the equivalent prime norm ideal for $J_\tau$, we can skip running
<code>EquivalentPrimeIdealHeuristic()</code> during the call to the KLPT algorithm within <code>IdealToIsogenyCoprime()</code>.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>