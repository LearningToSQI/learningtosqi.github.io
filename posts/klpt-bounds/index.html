<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="The KLPT algorithm takes an input left-$\OO_0$ ideal $I$ and computes an equivalent ideal $J$ with norm dividing some smooth integer $\TT$. At a high level, this is accomplished with the following steps:
Compute an ideal $L \sim I$ with prime norm: $n(L) = N$. Compute $\gamma \in \BB$ with reduced norm: $\Nrd(\gamma) = L_1 N$ with $L_1 \mathrel{|} \TT $. Compute $\mu \in \BB$ such that $\gamma \cdot \mu \in L$."><title>Estimating Bounds for KLPT</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Estimating Bounds for KLPT"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Estimating Bounds for KLPT"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Estimating Bounds for KLPT"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Estimating Bounds for KLPT</h1><p>The KLPT algorithm takes an input left-$\OO_0$ ideal $I$ and computes
an equivalent ideal $J$ with norm dividing some smooth integer $\TT$.
At a high level, this is accomplished with the following steps:</p><ol><li>Compute an ideal $L \sim I$ with prime norm: $n(L) = N$.</li><li>Compute $\gamma \in \BB$ with reduced norm: $\Nrd(\gamma) = L_1 N$ with $L_1 \mathrel{|} \TT $.</li><li>Compute $\mu \in \BB$ such that $\gamma \cdot \mu \in L$.</li><li>Compute $\nu \in \BB$ with $\Nrd(\nu) = L_2$ with $L_1 L_2 \mathrel{|} \TT $, using $\mu$.</li><li>Compute $\beta = \gamma \cdot \nu \in L$ with reduced norm $\Nrd(\beta) = L_1 L_2 N$.</li><li>Compute $J = \chi_L(\beta)$ with $n(J) = L_1 L_2$ such that $J \sim L \sim I$.</li></ol><p>In this discussion, we will not detail <em>how</em> all these steps work, but rather how
we choose the bounds we place on deriving the values $L_1$ and $L_2$ such that we can heuristically
rely on the algorithm to return $J$ with high probability.</p><p>Applying KLPT to SQISign, we want $L_1 L_2$ to be as small as possible to ensure that each
step is efficient. Most importantly, we need this to divide the available torsion on the curve
so we do not have to work with extension fields.
For <code>SigningKLPT()</code>, $L_1 L_2 = \ell^e$ is fixed from the parameter set, for security considerations,
but keeping the output norm small is important, as this controls the degree of the response isogeny
$\sigma$, and this computation is by far the most expensive in the SQISign protocol.</p><h2 id=searching-for-small-primes>Searching for small primes</h2><p>Although it is maybe not obvious from the steps outlined above, making $n(J)$ small
is all wrapped up in finding the smallest possible value of $n(L) = N$.</p><p>The trick to solving Step 1 is computing the Minkowski reduced basis of the input
ideal: $I = \langle \beta_1, \beta_2, \beta_3, \beta_4 \rangle$ and taking random
linear combinations of these basis elements until we find
some $\alpha \in I$ with norm $\Nrd(\alpha) = n(I) \cdot N$. We can then compute the equivalent
ideal $L \sim I = \chi_I(\alpha)$ with norm $n(L) = N$.</p><p><strong>Note</strong>: for random input, we would expect all elements of the reduced basis to have
reduced norm $\Nrd(\beta_i) \simeq \sqrt{p}$, and so we expect the norm of $L$ to be
$n(L) = N \simeq \sqrt{p}$. However, in SQISign, we occasionally have that ideals
have particularly small norm. When this happens, the reduced basis is orthogonal with
two elements of exceptionally small reduced norm. In these cases, it can be impossible
to find prime norm ideals with $n(L) &lt; p$. This is discussed in more detail on the page
<a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>.</p><p>For this discussion, let us write $p \simeq 2^{2\lambda}$ and assume we have obtained some ideal $L$
with prime norm $N \simeq 2^{\lambda + \delta}$, where $\delta$ is some small positive
value. The question is, how large can $\delta$ be before we are likely to find a solution?
We wish to pick $\delta$ small enough that we have a small output for $n(J)$, but large enough
that we are overwhelmingly likely to find solutions for the equivalent prime norm ideal and
hence for the KLPT algorithm.</p><h2 id=finding-a-quaternion-algebra-element-with-given-norm>Finding a quaternion algebra element with given norm</h2><p>The next step is to find $\gamma$ with norm $M = L_1 \cdot N$. This is accomplished with
<code>RepresentIntegerHeuristic()</code> and requires that the norm $M > p$. To find $\gamma$,
we have to be able to find a solution $M&rsquo; = x^2 + y^2$ using Cornacchia&rsquo;s algorithm.
On random input, we expect this to take roughly $\log(p)$ attempts, and so a good rule of thumb is to ensure
that $M > p\log(p) \simeq 2^{2\lambda + \epsilon}$. Assuming that $N \simeq 2^{\lambda + \delta}$
we then have a bound for $L_1 \simeq 2^{\lambda + \epsilon - \delta}$ where we expect
$\epsilon \simeq \log\log (p)$.</p><p>Practically, we do this by taking the input target norm $\TT$ and factoring it. We then
randomly take factors from $\TT$ for use in $L_1$ until $M$ is large enough such that we expect
to find a solution for $\gamma$. We then update $\TT^\prime = \TT / L_1$ for the following steps.</p><h2 id=finding-a-solution-to-the-strong-approximation>Finding a solution to the strong approximation</h2><p>Step four is where $N$ comes back into focus. Our goal is to find some $\nu$ with norm
$L_2$ such that $L_1 L_2$ divides the target norm $\TT$. From the estimates above, we
then have a maximal size for $L_2$ given $L_1$ computed earlier:</p><p>$$
L_{2}^{\text{Max}} = \TT / L_1 \simeq \TT \cdot 2^{\delta - \lambda - \epsilon}.
$$</p><p>Using the lattice method described in <a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a>,
we know that an approximate minimum bound for
the reduced norm is $\Nrd(\nu) \simeq pN^3$. This means practically we require
$\Nrd(\nu) = L_2 \geq pN^3$ for there to be a reasonable chance at finding a close vector.</p><p>Combining these two bounds, we must have that:</p><p>$$
L_{2}^{\text{Max}} \simeq \TT \cdot 2^{\delta - \lambda - \epsilon} \geq pN^3 \simeq 2^{5\lambda + 3\delta},
$$</p><p>which allow us to represent our heuristic bounds in terms of the target norm $\TT$:</p><p>$$
\TT > 2^{6\lambda + 2\delta + \epsilon} \simeq p^3 \cdot 2^{2\delta + \epsilon}.
$$</p><h2 id=concrete-bounds-for-sqisign>Concrete bounds for SQISign</h2><p>When running the KLPT algorithm in SQISign, we use it to find ideals with norm that divides the
available odd torsion. Further tricks described on the page <a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a>
allow us to square this such that $\TT = T^2$. We can then estimate our bounds by considering:</p><p>$$
\frac{T^2}{p^3} > 2^{2\delta + \epsilon},
$$</p><p>where both $p$ and $T$ are fixed constants for the protocol.
For the SQISign prime $p_{6983}$, we have that $p \simeq 2^{256}$ and $T \simeq 2^{428}$.
Using the bounds above, we have that $T^2 p^{-3} \simeq 2^{89}$. Allowing $\epsilon = \log\log(p) \simeq 8$
for solving $\textsf{RepresentInteger}_{\OO_0}$ we find the maximum possible value which allows solutions
would be $\delta = 40$.</p><p>Practically, we find that allowing $\delta \simeq \epsilon \simeq \log\log(p)$ seems to work with good
probability, however fine-tuning these constants will require more testing. Allowing $\delta$ to be smaller
than its maximum makes finding the prime norm a little harder, but makes finding a solution to the strong approximation
a little easier. As we randomly sample $L_i$, the bounds input into the strong approximation are more fuzzy, so
it appears helpful to save some bits by shrinking $\delta$.</p><p>As described on the page <a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a>, there are a few additional tricks which help keep the size of $N$ small, so setting
$\delta \simeq \log\log(p)$ seems fairly robust.</p><h2 id=setting-the-signing-length-of-sqisign>Setting the signing length of SQISign</h2><p>For the SQISign identification protocol to be zero-knowledge, the output of <code>response()</code> must have fixed length $\ell^e$.</p><p>The output of <code>response()</code> is a degree $\ell^e$ isogeny, which is derived from a cyclic ideal $J$ of norm $n(J) = \ell^e$.
The ideal $J$ is found by running <code>SigningKLPT()</code>, a generalisation of the KLPT algorithm which allows as input an
ideal $I$ with generic left order $\OO$ providing that a connecting ideal $I_\tau$ with left order $\OO_0$ and right order
$\OO$ is known.</p><p>We decompose $e$ as $e_1 + e_2$, where $L_1 = \ell^{e_1}$ and $L_2 = \ell^{e_2}$. The goal is to minimise $e$ for
efficiency of the protocol, while allowing it to be large enough that heuristically we always find an equivalent
ideal from <code>SigningKLPT()</code>.</p><p><strong>Setting</strong> $e_1$: In SQISign, we have a connecting ideal $I_\tau$ of prime norm, so we need not find an equivalent prime norm ideal.
Following the efficient <code>keygen()</code> from appendix D of the SQISign paper, the norm is also particularly
small: $n(I_\tau) \simeq p^{1/4}$. For the input ideal $I$, we will need an equivalent prime norm ideal $L \sim I$
which we expect
to have norm $n(L) \simeq \sqrt{p}$. We can set $e_1$ such that $L_1 \cdot n(L) > p$, and it very likely that we
find $\gamma \in \BB$ with norm $L_1 \cdot n(L)$.</p><p><strong>Setting</strong> $e_2$: As we want $e$ to be fixed, we then just allow $e_2 = e - e_1$, but how small can we make $L_2$
while still finding solutions? The size of $L_2$ becomes important when we attempt to solve a generalisation of the
strong approximation where the modulus is a composite integer: $N = n(L) \cdot n(I_\tau)$.</p><p>Using the lattice trick described in <a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a>,
we expect to find solutions of size $L_2 > pN^3$. Using the estimates
above, we have $L_1 > p^{1/2}$ and $L_2 > p^{13/4}$, so we should have $e > \frac{15}{4} \log_\ell(p)$. For the 256-bit
prime used in SQISign this would restrict us to $e > 960$ for a theoretical bound and $e = 1000$ is a comfortable
heuristic bound.</p><p>In practice, we set this bound for $e$ in <a href=https://github.com/LearningToSQI/SQISign-SageMath/blob/main/setup.py><code>setup.py</code></a> as a global variable. Then, when running <code>SigningKLPT()</code>, we set a sensible
value for $e_1$ once we find $n(L)$ for $L \sim I$.
Finally, we set $e_2 = e - e_1$ and attempt to solve the strong approximation for fixed $L_2$. If successful, we find
an ideal $J$ of norm $\ell^e$ equivalent to the input ideal $I$.</p><h3 id=fixing-the-signing-length>Fixing the signing length</h3><p>In fact, there is a little additional complication in setting $e_2$. When we compute an ideal using the KLPT
algorithm, the output ideal is not necessarily cyclic. So although we may have some ideal $J$ such that $n(J) = \ell^e$,
once we scale the ideal to ensure $J$ is cyclic (this is necessary such that the corresponding isogeny is cyclic),
we may find $J&rsquo;$ has norm $n(J&rsquo;) = \ell^{e-\epsilon_0}$, for some small $\epsilon_0$.</p><p>To deal with this, <code>SigningKLPT()</code> attempts to &ldquo;overshoot&rdquo; $L_2$ and pick some $\epsilon_0$ so we have $e_2 = e - e_1 + \epsilon_0$.
The output from the KLPT algorithm with then be some ideal of norm $n(J) = \ell^{e + \epsilon_0}$ and we hope that the cyclic
ideal $n(J&rsquo;)$ has norm exactly $\ell^e$.</p><p><strong>Note</strong>: we were unable to derive a way to ensure that the output had the correct norm. So ultimately we guess $\epsilon_0$ as best
as we can, and if $J&rsquo;$ has the wrong norm, we just run <code>SigningKLPT()</code> again. This does not add too much overhead to the computation
time, mainly because of how expensive the isogenies are currently.</p><p>Our current technique is to take</p><p>$$
\epsilon_0 = 2 \left\lfloor \frac{\log\log(p)}{4} \right\rfloor + \epsilon(\gamma).
$$</p><p>Where $\epsilon(\gamma)$ is a dynamic correction we make depending on the derived $\gamma \in \BB$ with
$\Nrd(\gamma) = L_1 n(L)$.</p><p>First, we write $\gamma$ in the basis of $\OO_0$ and compute $g$, the $\gcd$ of its coefficients.
We then compute the $\epsilon(\gamma) = \gcd(g, L_1)$. This might be easier to follow in code,
so we include the estimate below:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>quaternion_change_basis</span>(γ, O):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Computes the coefficients of a quaternion γ
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    in the basis of a given order O
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    O_matrix <span style=color:#fe8019>=</span> Matrix([b<span style=color:#fe8019>.</span>coefficient_tuple() <span style=color:#fe8019>for</span> b <span style=color:#fe8019>in</span> O<span style=color:#fe8019>.</span>basis()])
</span></span><span style=display:flex><span>    γ_vector <span style=color:#fe8019>=</span> vector(γ<span style=color:#fe8019>.</span>coefficient_tuple())
</span></span><span style=display:flex><span>    γO_coeffs <span style=color:#fe8019>=</span> γ_vector <span style=color:#fe8019>*</span> O_matrix<span style=color:#fe8019>.</span>inverse()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>assert</span> γ <span style=color:#fe8019>==</span> <span style=color:#fabd2f>sum</span>([a <span style=color:#fe8019>*</span> b <span style=color:#fe8019>for</span> a, b <span style=color:#fe8019>in</span> <span style=color:#fabd2f>zip</span>(γO_coeffs, O<span style=color:#fe8019>.</span>basis())])
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> γO_coeffs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>quarternion_basis_gcd</span>(γ, O):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Computes the gcd of the coefficients of a
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    quaternion γ in the basis of a given order O
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    γO_coeffs <span style=color:#fe8019>=</span> quaternion_change_basis(γ, O)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> gcd(γO_coeffs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>derive_L2_SigningKLPT</span>(γ, L1, e1):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Given L1 = l^e1 and γ try and compute L2
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    so that the output of SigningKLPT has norm
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    exactly 2^e
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    g <span style=color:#fe8019>=</span> quarternion_basis_gcd(γ, O0)
</span></span><span style=display:flex><span>    extra <span style=color:#fe8019>=</span> <span style=color:#d3869b>2</span> <span style=color:#fe8019>*</span> (floor(loglogp <span style=color:#fe8019>/</span> <span style=color:#d3869b>4</span>) <span style=color:#fe8019>+</span> ZZ(gcd(g, L1)<span style=color:#fe8019>.</span>valuation(l)))
</span></span><span style=display:flex><span>    e2 <span style=color:#fe8019>=</span> e <span style=color:#fe8019>-</span> e1 <span style=color:#fe8019>+</span> extra
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> l<span style=color:#fe8019>**</span>e2
</span></span></code></pre></div><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>