<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="In SQISign, we are most interested in a subset of integral ideals called cyclic ideals. This terminology is not standard, as they are usually called primitive, however we use this name in the context of SQISign to highlight their connection to cyclic isogenies (i.e., isogenies with cyclic kernel). They are defined as follows.
Definition. Let $I$ be an integral left $\OO$-ideal for some order $\OO$. We say that $I$ is cyclic if, for all prime $\ell$, we have that $I \nsubseteq \ell\OO$."><title>Working with Cyclic Ideals</title><meta name=description content="A SageMath implementation of SQISign"><link rel=canonical href=https://learningtosqi.github.io><meta property="og:type" content="website"><meta property="og:title" content="Learning to SQI | Working with Cyclic Ideals"><meta property="og:description" content="A SageMath implementation of SQISign"><meta property="og:url" content="https://learningtosqi.github.io/"><meta property="og:site_name" content="Learning to SQI | Working with Cyclic Ideals"><meta property="og:image" content="/images/banner.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Learning to SQI | Working with Cyclic Ideals"><meta name=twitter:description content="A SageMath implementation of SQISign"><meta name=twitter:site content="https://learningtosqi.github.io"><meta name=twitter:image content="/images/banner.png"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=f/avicon/safari-pinned-tab.svg color=#0017f5><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=msapplication-TileColor content="#00aba9"><meta name=msapplication-config content="/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,500;1,300&display=swap" rel=stylesheet><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><link rel=stylesheet href=/css/main.7bd2600936685e5cc7c0ae3b91978cfe3727b0609b2e43f94a050f2d2c922dbb5c196ba8242b7233074547a13c912b1bdc9086eca139f9a2f0aab829dd9e605f.css integrity="sha512-e9JgCTZoXlzHwK47kZeM/jcnsGCbLkP5SgUPLSySLbtcGWuoJCtyMwdFR6E8kSsb3JCG7KE5+aLwqrgp3Z5gXw=="><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{phi:"\\varphi",End:"\\textrm{End}",Nrd:"\\textrm{Nrd}",OO:"\\mathcal{O}",BB:"\\mathcal{B}_{p, \\infty}",NN:"\\mathcal{N}",TT:"\\mathcal{T}",ZZ:"\\mathbb{Z}",QQ:"\\mathbb{Q}",FF:"\\mathbb{F}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body a=auto><div class=wrapper><header><h1 class=title-header><a href=/>Learning to SQI</a></h1><h2 class=alt-title>Implementing SQISign in SageMath</h2><div class=authors>Maria Corte-Real Santos,
Giacomo Pope</div></header><main class=page-content aria-label=Content><div class=flex-wrapper><div class=flex-content><article><h1>Working with Cyclic Ideals</h1><p>In SQISign, we are most interested in a subset of integral ideals called <em>cyclic ideals</em>. This terminology is not standard, as they are usually called <em>primitive</em>, however we use this name in the context of SQISign to highlight their connection to cyclic isogenies (i.e., isogenies with cyclic kernel). They are defined as follows.</p><p><strong>Definition.</strong> Let $I$ be an integral left $\OO$-ideal for some order $\OO$. We say that $I$ is <em>cyclic</em> if, for all prime $\ell$, we have that $I \nsubseteq \ell\OO$.</p><p>As we only want to work with cyclic isogenies, we require all our ideals to be cyclic throughout our algorithms. Luckily, if we start with cyclic ideals, usually the output ideals after some operation will also be cyclic. For example, if we have cyclic ideals $I$ and $J$ of coprime norm, their product $IJ$ will also be cyclic. However, there are a few exceptions to this:</p><ul><li>When multiplying two ideals $I$, $J$ whose norm is not coprime, the ideal $IJ$ may not be cyclic.</li><li>Given input ideal $I$, the output of the KLPT algorithm (implemented as <code>EquivalentSmoothIdealHeuristic()</code>) may not be a cyclic ideal.</li></ul><p>Due to these exceptions, we need a method which given an integral ideal, returns a cyclic ideal.</p><h2 id=making-ideals-cyclic>Making ideals cyclic</h2><p>To make an integral ideal $I$ cyclic, we have written the function <code>make_cyclic()</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#fe8019>def</span> <span style=color:#fabd2f>make_cyclic</span>(I, full<span style=color:#fe8019>=</span><span style=color:#fe8019>False</span>):
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    Given an ideal I, returns a cyclic ideal by dividing
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    out the scalar factor g = ideal_basis_gcd(I)
</span></span></span><span style=display:flex><span><span style=color:#b8bb26>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Compute I as a linear combination of its left order basis</span>
</span></span><span style=display:flex><span>    I_basis <span style=color:#fe8019>=</span> I<span style=color:#fe8019>.</span>basis_matrix()
</span></span><span style=display:flex><span>    O_basis <span style=color:#fe8019>=</span> I<span style=color:#fe8019>.</span>left_order()<span style=color:#fe8019>.</span>unit_ideal()<span style=color:#fe8019>.</span>basis_matrix()
</span></span><span style=display:flex><span>    M <span style=color:#fe8019>=</span> I_basis <span style=color:#fe8019>*</span> O_basis<span style=color:#fe8019>.</span>inverse()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Compute the gcd of the gcd of the matrix rows </span>
</span></span><span style=display:flex><span>    g <span style=color:#fe8019>=</span> gcd((gcd(M_row) <span style=color:#fe8019>for</span> M_row <span style=color:#fe8019>in</span> M))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Ideal is already cyclic</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> g <span style=color:#fe8019>==</span> <span style=color:#d3869b>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span> I, g
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Scale the basis by the gcd</span>
</span></span><span style=display:flex><span>    J <span style=color:#fe8019>=</span> O<span style=color:#fe8019>.</span>left_ideal([b <span style=color:#fe8019>/</span> g <span style=color:#fe8019>for</span> b <span style=color:#fe8019>in</span> I<span style=color:#fe8019>.</span>basis()])
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> full:
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span> remove_2_endo(J)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> J, g
</span></span></code></pre></div><p>This algorithm works as follows.</p><ol><li>Given input integral ideal $I$, let $\OO$ be its left order.</li><li>Determine coefficients $x_1, \dots, x_4 \in \BB$ such that $I = x_1\beta_1 + \dots + x_4\beta_4$, where the $\beta_i$ form a basis of $\OO$.</li><li>Writing each $x_m$ as $a_m + b_mi + c_mj + d_mij$, let $g_m = \gcd(a_m, b_m, c_m, d_m)$.</li><li>Compute $g = \gcd(g_1, g_2, g_3, g_4)$.</li><li>If $g = 1$, then the ideal is cyclic, and we return $I$. Otherwise, letting $\alpha_1, \dots, \alpha_4$ be a basis for $I$, we return the left $\OO$-ideal generated by the $\alpha_1/g, \dots, \alpha_4/g$.</li></ol><p>We can optionally pass in <code>full = True</code> into <code>make_cyclic()</code>. In our current implementation of SQISign we do not use this, but we will exploit this in future when implementing the new <em>full</em> variants described in the <a href=https://eprint.iacr.org/2022/234>second SQISign paper</a>.</p><p><a href=#top>Back to Top</a></p></article></div><div class=flex-menu><div class=menu-header-mobile>Contents</div><div class=page-list><div class=menu-header>Contents</div><div class=contents><a href=/>Introduction</a></div><div class=contents><a href=/posts/overview/>Overview</a></div><div class=contents><a href=/posts/cyclic-ideals/>Working with Cyclic Ideals</a></div><div class=contents><a href=/posts/up-to-iso/>Correct up to Isomorphism</a></div><div class=contents><a href=/posts/pushforwards/>Pushforwards and Pullbacks</a></div><div class=contents><a href=/posts/klpt-bounds/>Estimating Bounds for KLPT</a></div><div class=contents><a href=/posts/prime-ideal/>Equivalent Prime Norm Ideals</a></div><div class=contents><a href=/posts/strong-approximation-lattice/>Strong Approximation Lattice Trick</a></div><div class=contents><a href=/posts/ideal-kernel/>Between Kernels and Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny/>Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/ideal-to-isogeny-subroutines/>Subroutines when Computing Isogenies from Ideals</a></div><div class=contents><a href=/posts/meet-in-the-middle/>Meet in the Middle Isogenies</a></div><div class=contents><a href=/posts/small-steps/>Small Steps from Curves with Small Endomorphisms</a></div><div class=contents><a href=/posts/compression/>Modifying Compression</a></div><div class=contents><a href=/posts/future-work/>Future Work</a></div></div></div></div></main></div></body><footer><div class=footer-left><div class=footer-title>Learning to SQI<br><em>Implementing SQISign in SageMath</em></div><div class=footer-authors>Maria Corte-Real Santos,
Giacomo Pope</div></div><div class=footer-right><a href=https://github.com/jack4818/SQISign-SageMath><img class=social-link alt=GitHub src=/images/github.svg></a></div></footer></html>